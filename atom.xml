<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>heqiao2010</title>
  
  <subtitle>blog of heqiao2010</subtitle>
  <link href="http://heqiao2010.github.io/atom.xml" rel="self"/>
  
  <link href="http://heqiao2010.github.io/"/>
  <updated>2021-08-14T12:30:41.165Z</updated>
  <id>http://heqiao2010.github.io/</id>
  
  <author>
    <name>heqiao2010</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis中的三种不常见数据类型之geo</title>
    <link href="http://heqiao2010.github.io/2020/10/24/redis%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bgeohash/"/>
    <id>http://heqiao2010.github.io/2020/10/24/redis%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bgeohash/</id>
    <published>2020-10-24T15:02:06.000Z</published>
    <updated>2021-08-14T12:30:41.165Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这次介绍一个在地理定位系统中使用的比较多的一种数据类型——geo。geo是geography的缩写，说明和地理位置有关，geohash可以认为是一种特殊的编码格式。</p></blockquote><h1 id="geo"><a href="#geo" class="headerlink" title="geo"></a>geo</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>geo是redis在3.2.0及以上版本，中的一个特殊的集合，提供存储经纬度，计算距离范围等功能。和bitmap，hyperloglog不同的是，geo在redis中存储的类型是zset。也就是说除了支持geo相关的api之外，完全兼容zset的所有api。</p><h3 id="geoadd"><a href="#geoadd" class="headerlink" title="geoadd"></a>geoadd</h3><p>该指令用于添加地理位置信息，往某个集合中添加地理位置坐标——<code>geoadd 集合名称 经度 纬度 地理位置名称</code>。</p><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; geoadd mygeo <span class="hljs-number">116.4</span> <span class="hljs-number">39.92</span> beijing(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt;</code></pre><h3 id="geopos"><a href="#geopos" class="headerlink" title="geopos"></a>geopos</h3><p>用于获取集合中某个坐标具体的经纬度——<code>geopos 集合名称 地理位置名称</code>。</p><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; geopos mygeo beijing<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;116.39999896287918091&quot;</span>   <span class="hljs-number">2</span>) <span class="hljs-string">&quot;39.9199990416181052&quot;</span></code></pre><h3 id="geodist"><a href="#geodist" class="headerlink" title="geodist"></a>geodist</h3><p>用于计算同一个集合当中，两个坐标之间的距离，支持m，km，ft等单位——<code>geodist 集合名称 地理位置名称1 地理位置名称2 </code>。</p><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; geoadd mygeo <span class="hljs-number">114.0</span> <span class="hljs-number">30.58</span> wuhan(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; geodist mygeo beijing wuhan km<span class="hljs-string">&quot;1061.3546&quot;</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt;</code></pre><h3 id="georadius"><a href="#georadius" class="headerlink" title="georadius"></a>georadius</h3><p>用于获取集合中，某个半径范围内的坐标信息，可以获取坐标值，也可以获取坐标对应的距离等。</p><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; georadius mygeo <span class="hljs-number">114</span>.<span class="hljs-number">0</span> <span class="hljs-number">30</span>.<span class="hljs-number">58</span> <span class="hljs-number">1070</span> km WITHCOORD WITHDIST<span class="hljs-attribute">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;wuhan&quot;</span>   <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;0.0001&quot;</span>   <span class="hljs-attribute">3</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;114.00000125169754028&quot;</span>      <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;30.58000021509926825&quot;</span><span class="hljs-attribute">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;beijing&quot;</span>   <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;1061.3546&quot;</span>   <span class="hljs-attribute">3</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;116.39999896287918091&quot;</span>      <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;39.9199990416181052&quot;</span><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt;</code></pre><h3 id="georadiusbymember"><a href="#georadiusbymember" class="headerlink" title="georadiusbymember"></a>georadiusbymember</h3><p>和georadius命令功能相同，只是指定中心点换成了坐标名称。</p><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; geoadd mygeo <span class="hljs-number">117.30</span> <span class="hljs-number">39.71</span> tianjing(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; georadiusbymember mygeo wuhan <span class="hljs-number">1070</span> km WITHCOORD WITHDIST<span class="hljs-number">1</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;wuhan&quot;</span>   <span class="hljs-number">2</span>) <span class="hljs-string">&quot;0.0000&quot;</span>   <span class="hljs-number">3</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;114.00000125169754028&quot;</span>      <span class="hljs-number">2</span>) <span class="hljs-string">&quot;30.58000021509926825&quot;</span><span class="hljs-number">2</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;tianjing&quot;</span>   <span class="hljs-number">2</span>) <span class="hljs-string">&quot;1058.6922&quot;</span>   <span class="hljs-number">3</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;117.29999810457229614&quot;</span>      <span class="hljs-number">2</span>) <span class="hljs-string">&quot;39.70999992828803471&quot;</span><span class="hljs-number">3</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;beijing&quot;</span>   <span class="hljs-number">2</span>) <span class="hljs-string">&quot;1061.3546&quot;</span>   <span class="hljs-number">3</span>) <span class="hljs-number">1</span>) <span class="hljs-string">&quot;116.39999896287918091&quot;</span>      <span class="hljs-number">2</span>) <span class="hljs-string">&quot;39.9199990416181052&quot;</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt;</code></pre><p>值得注意的是，这里并没有提供geodel，因为本质上它是一个zset，所以是支持所有zset指令的，可以通过zrem来进行删除。</p><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrem mygeo tianjing(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mygeo <span class="hljs-number">0</span> <span class="hljs-number">10</span> WITHSCORES<span class="hljs-number">1</span>) <span class="hljs-string">&quot;wuhan&quot;</span><span class="hljs-number">2</span>) <span class="hljs-string">&quot;4052113222296933&quot;</span><span class="hljs-number">3</span>) <span class="hljs-string">&quot;beijing&quot;</span><span class="hljs-number">4</span>) <span class="hljs-string">&quot;4069885561465124&quot;</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt;</code></pre><h2 id="geohash编码"><a href="#geohash编码" class="headerlink" title="geohash编码"></a>geohash编码</h2><p>从上面zset的value可以看出，redis进行存储的时候，并不是直接存储的坐标值，而是将二维坐标做了编码。接下来看看这种geohash的编码是如何实现的。</p><p>Geohash本质上是空间索引的一种方式，其基本原理是将地球理解为一个二维平面，将平面递归分解成更小的子块，每个子块在一定经纬度范围内拥有相同的编码。以GeoHash方式建立空间索引，可以提高对空间数据进行经纬度检索的效率。首先是将世界地图划分为了32等分，每一等分分配一个编码，然后每一等分又继续分为32等分，按照同样的方式进行编码，依次递归。</p><img src="/images/17.png" alt="geohash" style="zoom:80%;" /><p>这样递归了n次之后，就会得到一个长度为n的字符串，比如北京的位置，大概为：wx4g0e；如果还要更加精确的值，则获取更长的编码即可。那么通过这种方式简化了之后，对地理位置的查询，就由二维坐标的查询，变成了一维字符串的查询。性能较高，而且节省了存储空间，并且在某些场景下还可以达到保护隐私的效果——方便的提供大概位置。</p><h4 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h4><p>那么具体是怎么编码的呢，以经纬度值：（116.389550， 39.928167）为例进行说明：</p><ol><li><p>区间[-90,90]进行二分为[-90,0),[0,90]，称为左右区间，可以确定39.928167属于右区间[0,90]，给标记为1；</p></li><li><p>接着将区间[0,90]进行二分为 [0,45),[45,90]，可以确定39.928167属于左区间 [0,45)，给标记为0；</p></li><li><p>递归上述过程39.928167总是属于某个区间[a,b]。随着每次迭代区间[a,b]总在缩小，并越来越逼近39.928167；</p></li><li><p>如果给定的纬度x（39.928167）属于左区间，则记录0，如果属于右区间则记录1，序列的长度跟给定的区间划分次数有关；<img src="/images/18.png" alt="编码过程"></p></li><li><p>同理，地球经度区间是[-180,180]，可以对经度116.389550进行编码</p></li><li><p>通过上述计算，纬度产生的编码为1 1 0 1 0 0 1 0 1 1 0 0 0 1 0</p><p>经度产生的编码为1 0 1 1 1 0 0 0 1 1 0 0 0 1 1</p></li><li><p>合并：偶数位放经度，奇数位放纬度，把2串编码组合生成新串：<img src="/images/19.png" alt="合并结果"></p></li><li><p>然后将11100 11101 00100 01111 0000  01101转成十进制，对应着28、29、4、15，0，13 十进制对应的base32编码就是wx4g0e,如下图：</p><p><img src="/images/20.png" alt="编码"></p></li></ol><p>当geohash base32编码长度为8时，精度在19米左右，而当编码长度为9时，精度在2米左右。</p><img src="/images/21.png" alt="精度说明" style="zoom:80%;" /><h3 id="geohash编码的缺陷"><a href="#geohash编码的缺陷" class="headerlink" title="geohash编码的缺陷"></a>geohash编码的缺陷</h3><p>对大部分而言，编码相似的距离也相近，但geohash是通过Peano空间曲线填充的，这种曲线最大的缺点就是突变性，有些编码相邻但距离却相差很远，比如下左图中g与h，编码是相邻的，但距离相差很大。</p><p>突变性的规避方法：<br>查询附近地点，除了使用定位点的GeoHash编码进行匹配外，还使用周围8个区域的GeoHash编码，这样可以避免这个问题。</p><p><img src="/images/22.png" alt="peano"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>redis中的geo特别适合微信中摇一摇，外卖骑手位置定位等，涉及热点定位数据的场景。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://geohash.org/wx4g0e">http://geohash.org/wx4g0e</a></p><p><a href="http://geohash.gofreerange.com/">http://geohash.gofreerange.com</a></p><p><a href="https://en.wikipedia.org/wiki/Geohash">https://en.wikipedia.org/wiki/Geohash</a></p><p><a href="http://geohash.org/">http://geohash.org/</a></p><p><a href="https://www.cnblogs.com/LBSer/p/3298057.html">https://www.cnblogs.com/LBSer/p/3298057.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这次介绍一个在地理定位系统中使用的比较多的一种数据类型——geo。geo是geography的缩写，说明和地理位置有关，geohash可以认为是一种特殊的编码格式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;geo&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="redis" scheme="http://heqiao2010.github.io/categories/redis/"/>
    
    
    <category term="geohash" scheme="http://heqiao2010.github.io/tags/geohash/"/>
    
  </entry>
  
  <entry>
    <title>redis中的三种不常见数据类型之hyperloglog</title>
    <link href="http://heqiao2010.github.io/2020/10/24/redis%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bhyperloglog/"/>
    <id>http://heqiao2010.github.io/2020/10/24/redis%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bhyperloglog/</id>
    <published>2020-10-24T01:39:50.000Z</published>
    <updated>2021-08-14T12:30:42.013Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上次介绍了bitmap和bloomfilter，这次介绍一个在大数据领域比较常见的数据类型或者说一种算法——hyperLogLog。</p></blockquote><h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>redis中的HyperLogLog是一个基数计数器，在2.8.9及以上版本中提供。所谓基数（Distinct Value，简称DV）是指一个集合当中不相同元素的个数，而HyperLogLog就是这样一个计数器，能够用极小空间，来统计集合中不同元素的个数。和bitmap类似，在redis中，HyperLogLog也是一个字符串（为了标识这个字符串以HYLL打头）。</p><h3 id="指令介绍"><a href="#指令介绍" class="headerlink" title="指令介绍"></a>指令介绍</h3><p>HyperLogLog的指令比较简单，只有三个：pfadd，pfcount以及pfmerge。</p><h4 id="pfadd"><a href="#pfadd" class="headerlink" title="pfadd"></a>pfadd</h4><p>用于向集合当中添加元素。</p><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; pfadd test <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; pfadd test <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; pfadd test <span class="hljs-string">&quot;hello world&quot;</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; type test<span class="hljs-built_in">string</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">get</span> test<span class="hljs-string">&quot;HYLL\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80]f\x80GN\x8cF$\x80Q,\x8cC\xf3&quot;</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt;</code></pre><h4 id="pfcount"><a href="#pfcount" class="headerlink" title="pfcount"></a>pfcount</h4><p>用于统计集合的基数。</p><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; pfcount test(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">4</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; pfadd test <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; pfcount test(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">7</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt;</code></pre><h4 id="pfmerge"><a href="#pfmerge" class="headerlink" title="pfmerge"></a>pfmerge</h4><p>用于合并多个hyperloglog，<code>pfmerge deskey sourcekey1 sourcekey2...</code>。</p><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; pfadd test2 <span class="hljs-number">0.1</span> <span class="hljs-number">0.2</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; pfmerge test3 test test2OK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; pfcount test3(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">9</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; pfcount test2(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">2</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; pfcount test(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">7</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt;</code></pre><h4 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h4><p>之前介绍过hyperloglog通过极小的内存就能计算非常大集合的基数。我们可以用之前计算DAU的场景来模拟一下，假如用hyperloglog来存储活跃用户的ID，看看占用多大空间。用如下脚本来创建5千万个字符串id，看看最终的value有多长。</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>elements=&quot;&quot;key=&quot;test_hyperloglog&quot;for((i=1;i&lt;=50000000;i++)); do        elements=&quot;$&#123;key&#125;_uuid_&quot;$&#123;i&#125;        ./redis-cli pfadd $&#123;key&#125; $&#123;elements&#125;        echo &quot;add $&#123;elements&#125;&quot;doneecho &quot;done.&quot;</code></pre><p>该脚本执行完比较耗时，（我这里没有执行完）在往redis中添加了14102763个字符串id后，最终的value字符串长度只有：12304,相当于12KB，可见hyperLogLog是很节省空间的。此外从pfcount得出的估计值：14261991，和实际值是有误差的，将近大了1.12%。</p><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; strlen test_hyperloglog(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">12304</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; pfcount test_hyperloglog(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">14261991</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt;</code></pre><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>在介绍hyperloglog算法之前，可以先从生活中常见的一个例子讲起。如果有这样一个问题：假设某人抛了很多次硬币，并告诉我们在这次抛硬币的过程中最多只有两次扔出连续的反面，让我们猜总共抛了多少次硬币？</p><p><img src="/images/9.jpg" alt="抛硬币"></p><p>从感性上来看，如果只是连续两次反面，抛硬币的总次数应该不会很多，因为这种情况很容易出现；如果说是连续抛了10次都是反面，那么可以说明这个人很可能抛了特别多次，因为连续10次反面的情况并不多见。</p><p>如果要设计一个计算求抛硬币总数的算法，则可以通过如下思路进行设计：</p><p>定义一个二进制序列，假设1代表抛出正面，0代表反面。那么连续两次反面，则是连续出现两个0，由于是连续两个0，那么第三个应该就是1，那么必定出现的序列就是001，那么这样的概率就好计算了，就是(1/2)^3,也就是1/8，即这个人大概抛了8次硬币。</p><img src="/images/10.png" alt="抛硬币计算方法" style="zoom:67%;" /><p>同样在计算机中，将某个对象的哈希值，转化为二进制，其中的0和1就和抛硬币比较类似了。不过为了简化，只取哈希值二进制中最前面连续的0的数量，即前导0。那么根据抛硬币受到的启发，求一个集合的基数，可以得到如下算法：</p><pre><code class="hljs livecodeserver">输入：一个集合输出：集合的基数算法：     <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span>     对于集合中的每个元素：               hashCode = hash(元素)               <span class="hljs-built_in">num</span> = hashCode二进制表示中最前面连续的<span class="hljs-number">0</span>的数量（前导<span class="hljs-number">0</span>）               <span class="hljs-keyword">if</span> <span class="hljs-built_in">num</span> &gt; <span class="hljs-built_in">max</span>:                   <span class="hljs-built_in">max</span> = <span class="hljs-built_in">num</span>     最后的结果是<span class="hljs-number">2</span>的(<span class="hljs-built_in">max</span> + <span class="hljs-number">1</span>)次幂</code></pre><p>上面这种做法虽然能够做一个大致的估算，但是显然误差是比较大的，很容易受到突发事件（比如突然连续抛出好多0）的影响，HyperLogLog之类的算法研究的就是如何减小这个误差。</p><p><strong>分桶（LogLog）</strong></p><p>最简单的一种优化方法显然就是把数据分成m个均等的部分，分别估计其总数求平均后再乘以m，称之为分桶。对应到前面抛硬币的例子，其实就是把硬币序列分成m个均等的部分，分别用之前提到的那个方法估计总数求平均后再乘以m，这样就能一定程度上避免单一突发事件造成的误差。</p><p>例如分桶个数为2，那么可以通过哈希值的第一位映射到不同的桶中，然后分别计算每个桶中前导0的最大值，然后计算前导0+1最大值的平均值得到最终解决。这种方法，在一定程度上可以减少偶然因素导致的误差影响。</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">hash</span><span class="hljs-params">(ele1)</span></span> = <span class="hljs-number">00110111</span> <span class="hljs-function"><span class="hljs-title">hash</span><span class="hljs-params">(ele2)</span></span> = <span class="hljs-number">10010001</span></code></pre><img src="/images/11.png" alt="分桶思路" style="zoom:50%;" /><p>经过分桶的优化之后，该方法和LogLog算法很接近了，该算法的计算公式为：</p><p><img src="/images/12.png" alt="LogLog算法公式"></p><pre><code class="hljs ada">m：代表分桶数；R：代表每个桶的结果（其实就是桶中数据的最长前导零+<span class="hljs-number">1</span>）的均值<span class="hljs-keyword">constant</span> :修正常数</code></pre><p>修正常数的计算：先计算出：p = log2m。</p><pre><code class="hljs angelscript"><span class="hljs-keyword">switch</span> (p) &#123;   <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:       constant = <span class="hljs-number">0.673</span> * m * m;   <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:       constant = <span class="hljs-number">0.697</span> * m * m;   <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:       constant = <span class="hljs-number">0.709</span> * m * m;   <span class="hljs-keyword">default</span>:       constant = (<span class="hljs-number">0.7213</span> / (<span class="hljs-number">1</span> + <span class="hljs-number">1.079</span> / m)) * m * m;&#125;</code></pre><p><strong>关于平均数</strong></p><p>HyperLogLog算法对LogLog算法有一些改进，其中一个就是改进了平均数的计算方式。在LogLog算法中，每个分桶的前导0+1的平均方法采用的是最简单的算术平均法。</p><p>而对于平均数，不同的求法会导致计算结果不同。之前在知乎上看到一个关于平均数的讨论，挺有意思的：问题的场景是，某人每周需要买一次菜，有两种购买方式，一是每次买固定金额的，而是每次买固定重量的，问那种购买方式比较合算？</p><pre><code class="hljs awk">假设连续买菜n周，每周的菜价为ai方式一，每周买菜重量固定为A，那么求平均价格：A*(a1+ a2+…+an)<span class="hljs-regexp">/A*n=(a1+a2+…+an)/</span>n方式二，每周买菜金额固定为M，那么求平局价格：nM<span class="hljs-regexp">/(M/</span>a1+M<span class="hljs-regexp">/a2+…+M/</span>an=n<span class="hljs-regexp">/(1/</span>a1+<span class="hljs-number">1</span><span class="hljs-regexp">/a2+…+1/</span>an）</code></pre><p>显然每次购买固定金额的，是比较合算的；一个比较感性的理解是，如果某天菜价上涨了，那么购买的就少；反之菜价便宜就购买的多，自然这种方式会合算些。实际上方式一求的是算术平均数，方式二，求的是调和平均数；除了这两种还有其他几种平均数的计算方式。它们的关系是：Hn &lt;= Gn &lt;= An &lt;= Qn。</p><img src="/images/13.png" alt="平均数的计算方式" style="zoom:54%;" /><p>回到求集合基数的问题中，我们寻求一种比较好的平均数的计算方式，是为了减少偶然因素带来的误差，而这个误差会导致求的的结果偏大，显然可以用计算结果偏小的调和平均方式，来抵消一部分误差的影响。</p><p>采用调和平均数：</p><img src="/images/14.png" alt="HyperLogLog算法" style="zoom:70%;" /><p>即：</p><img src="/images/15.png" alt="HyperLogLog算法" style="zoom:60%;" /><p>数据总量比较小的时候，很容易就预测偏大，hyperLogLog还有其他的微调。</p><pre><code class="hljs angelscript"><span class="hljs-keyword">if</span> DVs &lt; (<span class="hljs-number">5</span> / <span class="hljs-number">2</span>) * m: DV = m * ln(m/V)</code></pre><p>DVs代表估计的基数值，m代表桶的数量，V代表结果为0的桶的数目，就是没有数据的桶。</p><p>网上有一个LL和HYLL算法的<a href="http://content.research.neustar.biz/blog/hll.html">对比演示</a>，做的很直观，可以参考下。</p><p>Redis官方给的错误率是：0.81%，我这里通过python脚本，实验了一下，误差率是比这个结果要大一些的。</p><p>测试脚本：</p><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> redis<span class="hljs-keyword">import</span> <span class="hljs-type">uuid</span>TEST_KEY = <span class="hljs-string">&#x27;hyperloglog&#x27;</span>TEST_FILE = &quot;hyperloglog3.txt&quot;logfile = <span class="hljs-keyword">open</span>(TEST_FILE, &quot;w&quot;)rediscli = redis.Redis(host=<span class="hljs-string">&#x27;localhost&#x27;</span>, port=<span class="hljs-number">6379</span>, decode_responses=<span class="hljs-keyword">True</span>)  # cleanrediscli.<span class="hljs-keyword">delete</span>(TEST_KEY)print(&quot;before test count: &quot; + str(rediscli.pfcount(TEST_KEY)))# <span class="hljs-keyword">do</span> test<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">1000001</span>):    uuid_str = str(<span class="hljs-type">uuid</span>.uuid1())    # print(str(i) + &quot;: generate uuid: &quot; + uuid_str)    rediscli.pfadd(TEST_KEY, uuid_str)    # logfile.<span class="hljs-keyword">write</span>(str(i) + &quot; : &quot; + uuid_str + &quot;\n&quot;)    <span class="hljs-keyword">if</span> i % <span class="hljs-number">10000</span> == <span class="hljs-number">0</span>:        logcount = rediscli.pfcount(TEST_KEY)        logfile.<span class="hljs-keyword">write</span>(&quot;Actual Cardinality: &quot; + str(i) + &quot; Estimated Cardinality: &quot; + str(logcount) + &quot; Error%&quot; + str(format(<span class="hljs-type">float</span>((logcount - i) * <span class="hljs-number">100</span>) / <span class="hljs-type">float</span>(i), <span class="hljs-string">&#x27;.2f&#x27;</span>)) + &quot;\n&quot;)logfile.<span class="hljs-keyword">close</span></code></pre><p>测试结果：</p><p><img src="/images/16.png" alt="实验结果"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>hyperLogLog是一个利用概率统计来估算某个集合数据量的算法，有支持的数据量大，性能高，占用内存小的特点，由于是一个估算算法，所以没法得到精确值。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://content.research.neustar.biz/blog/hll.html">http://content.research.neustar.biz/blog/hll.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/36306868">https://zhuanlan.zhihu.com/p/36306868</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;上次介绍了bitmap和bloomfilter，这次介绍一个在大数据领域比较常见的数据类型或者说一种算法——hyperLogLog。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;HyperLogLog&quot;&gt;&lt;a href=&quot;#HyperLog</summary>
      
    
    
    
    <category term="redis" scheme="http://heqiao2010.github.io/categories/redis/"/>
    
    
    <category term="hyperloglog" scheme="http://heqiao2010.github.io/tags/hyperloglog/"/>
    
  </entry>
  
  <entry>
    <title>redis中的三种不常见数据类型之bitmap</title>
    <link href="http://heqiao2010.github.io/2020/10/23/redis%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bbitmap/"/>
    <id>http://heqiao2010.github.io/2020/10/23/redis%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8Bbitmap/</id>
    <published>2020-10-23T11:28:01.000Z</published>
    <updated>2021-08-14T12:30:40.829Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>除了常见的五种数据类型之外，在redis的高版本中，开始支持一些相对高级的数据结构；下面介绍一下redis中的位图（bitmap）。</p></blockquote><h1 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>bitmap即位图，redis在2.2.0及以上版本开始支持。位图的功能是支持基本的位操作，可以通过给定的api修改或者读取数据中某个位上的值。虽然bitmap新增了相关的api，但本质上在redis中还是以字符串的形式存储的。</p><p>比如big这个字符串，在redis中以如下二进制存储；如果通过setbit指令，将第8位置为1，则字符串的值就变成了cig，这和通过set命令将值更新为cig是相同的效果。 </p><p><img src="/images/1.png" alt="bitmap的存储"></p><h3 id="setbit和getbit"><a href="#setbit和getbit" class="headerlink" title="setbit和getbit"></a>setbit和getbit</h3><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">set</span> bitmap big OK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; setbit bitmap <span class="hljs-number">7</span> <span class="hljs-number">1</span> #给位图指定索引设置值(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">get</span> bitmap<span class="hljs-string">&quot;cig&quot;</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; getbit bitmap <span class="hljs-number">7</span>   #获取位图指定索引的值(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; getbit bitmap <span class="hljs-number">6</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt;</code></pre><p><img src="/images/2.png" alt="bitmap扩容"></p><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; setbit bitmap <span class="hljs-number">50</span> <span class="hljs-number">0</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">get</span> bitmap<span class="hljs-string">&quot;cig\x00\x00\x00\x00&quot;</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; setbit bitmap <span class="hljs-number">50</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">get</span> bitmap<span class="hljs-string">&quot;cig\x00\x00\x00 &quot;</span></code></pre><p>如果设置一个很大索引值，那么这个字符串会动态扩容到对应的长度。由于这个特性，offset过大，会导致耗时比较长，有阻塞风险。我们知道在redis中String最大为512M，因此offset也是有最大值的。此外setbit指令不会重置对应Key的过期时间戳。</p><p>在一台2010MacBook Pro上，测试结果如下：</p><table><thead><tr><th>offset值</th><th>分配内存大小（MB）</th><th>耗时（ms）</th></tr></thead><tbody><tr><td>2^32-1</td><td>512</td><td>300</td></tr><tr><td>2^30-1</td><td>128</td><td>80</td></tr><tr><td>2^28-1</td><td>32</td><td>30</td></tr><tr><td>2^26-1</td><td>8</td><td>8</td></tr></tbody></table><p>除了setbit和getbit这两个指令外，还有bitcount，bitop以及bitpos三个指定。它们的作用分别如下：</p><h3 id="bitcount"><a href="#bitcount" class="headerlink" title="bitcount"></a>bitcount</h3><p>用于计算bitmap中，指定范围内1的个数，注意这里的start和end值不是offset，它们的单位是字节，比如：<code>bitcount bitmap 0 1</code>是计算第一个字节中有多少位为1。</p><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">get</span> bitmap<span class="hljs-string">&quot;big&quot;</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; bitcount bitmap <span class="hljs-number">0</span> <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">7</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; bitcount bitmap <span class="hljs-number">1</span> <span class="hljs-number">2</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">9</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; type bitmap<span class="hljs-built_in">string</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt;</code></pre><h3 id="bitop"><a href="#bitop" class="headerlink" title="bitop"></a>bitop</h3><p>用于对bitmap集合做操作，例如：and（与），or（并），xor（异或），not（对某个集合取反），操作的结果放到指定的目标key中。</p><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; set bitmap1 aOK<span class="hljs-number">127.0.0.1:6379</span>&gt; set bitmap2 bOK<span class="hljs-number">127.0.0.1:6379</span>&gt; bitop and bitmap3 bitmap1 bitmap2(integer) <span class="hljs-number">1</span><span class="hljs-number">127.0.0.1:6379</span>&gt; get bitmap3<span class="hljs-string">&quot;`&quot;</span><span class="hljs-number">127.0.0.1:6379</span>&gt; bitop or bitmap3 bitmap1 bitmap2(integer) <span class="hljs-number">1</span><span class="hljs-number">127.0.0.1:6379</span>&gt; get bitmap3<span class="hljs-string">&quot;c&quot;</span><span class="hljs-number">127.0.0.1:6379</span>&gt; bitop xor bitmap3 bitmap1 bitmap2(integer) <span class="hljs-number">1</span><span class="hljs-number">127.0.0.1:6379</span>&gt; get bitmap3<span class="hljs-string">&quot;\x03&quot;</span><span class="hljs-number">127.0.0.1:6379</span>&gt; bitop not bitmap3 bitmap1(integer) <span class="hljs-number">1</span><span class="hljs-number">127.0.0.1:6379</span>&gt; get bitmap3<span class="hljs-string">&quot;\x9e&quot;</span><span class="hljs-number">127.0.0.1:6379</span>&gt;</code></pre><h3 id="bitpos"><a href="#bitpos" class="headerlink" title="bitpos"></a>bitpos</h3><p>用于计算bitmap中，第一次出现1或者0的位置（offset）。</p><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">set</span> bitmap bigOK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; getbit bitmap <span class="hljs-number">0</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; getbit bitmap <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; getbit bitmap <span class="hljs-number">2</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; getbit bitmap <span class="hljs-number">3</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; bitpos bitmap <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt;</code></pre><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="计算DAU"><a href="#计算DAU" class="headerlink" title="计算DAU"></a>计算DAU</h3><p>位图（bitmap）在某些场景下可以很方便的用来计算日活量（DAU），比如有一个1亿用户，日活量可能到达5千万的系统；如果需要统计某段时间内，活用用户数的话，首先想到的可能是用集合来做，比如每天，都将活跃用户的id存储到一个指定的集合当中，然后计算这个集合的大小就可以得到日活数；也可以用这个集合来判断某个用户是否在该集合中，用来判断某个用户在某天是否上线过。</p><p>除了直接采用集合这种方式，也可以使用位图来存储。前提是每个用户都可以用唯一的一个正整数来表示，比如用户Id是个bigInt类型的正整数，这就很适合这种场景。如果用户在某天上线了，只需要将该bit位置为1即可，求上线用户数，就变成了求bitmap中1的个数，求某个用户是否在某天上线，就可以转化为求bitmap中对应位是否为1。</p><p>此外在一定情况下，采用bitmap，比直接采用集合更加节省空间。</p><table><thead><tr><th>数据类型</th><th>每个userId占用的空间</th><th>需要存储的用户量</th><th>全部内存</th></tr></thead><tbody><tr><td>Set</td><td>32(假设是int)</td><td>50,000,000</td><td>200M</td></tr><tr><td>Bitmap</td><td>1bit</td><td>100,000,000</td><td>12.5M</td></tr></tbody></table><h3 id="实现bloomFilter"><a href="#实现bloomFilter" class="headerlink" title="实现bloomFilter"></a>实现bloomFilter</h3><h4 id="介绍下布隆过滤器"><a href="#介绍下布隆过滤器" class="headerlink" title="介绍下布隆过滤器"></a>介绍下布隆过滤器</h4><p>BloomFilter是一个很有名的数据结构，它是由一个长度为m比特的位数组（bit array）与k个哈希函数（hash function）组成的数据结构。位数组均初始化为0，所有哈希函数都可以分别把输入数据尽量均匀地散列。这种数据结构特别适合用来解决一些存在性问题——即判断某个元素是否在某个集合当中。</p><p>一般的集合，比如HashSet之类的，存在一些不足。当集合当中元素的个数特别大的时候，占用的空间会非常大，同时出现哈希碰撞的概率也将增大。而BF（bloomFilter）在一定程度上解决了这个问题。</p><p><img src="/images/3.png" alt="布隆过滤器"></p><p>以上图作为一个例子，介绍一下BF的工作流程。首先这个BF由18个bit数组以及3个哈希函数组成。初始化时，所有bit位都是0，在往集合中加入元素时，依次利用每一个哈希函数计算元素的哈希值，然后将哈希值映射到m数组上，并将对应bit位置为1。将全部元素添加完成后，BF就初始化好了。此时，就可以用来判断一个新元素w，是否在这个<code>&#123;x,y,z&#125;</code>集合当中；首先和添加元素时类似，依次用哈希函数计算w的值，然后映射到m数组上，然后看数组上对应的bit位是否都是1，如果都是1，则说明w<strong>可能</strong>存在该集合当中，如果存在某次哈希值映射位上是0，则说明w<strong>一定不</strong>存在这个集合当中。 </p><p>通过上面的表述，可以知道BF有如下特性——如果判断结果是不在集合中，那么该元素一定不在该集合当中；如果判断结果是在集合当中，那么只能说该元素可能在集合当中。</p><p>为什么说只是可能在集合当中呢？因为存在哈希冲突的可能，即k个哈希函数计算的值，都存在冲突，这样即使新元素w的哈希值的k个映射位都是1，也不能说明w就一定存在集合当中；而只能说这种可能性比较大。可以用上图来做简单说明，假如w最后一次映射的bit位也是1，那么w就满足所有映射位都是1的条件，但是w这个元素确实是个新元素，即出现了假阳性（False Positive）概率事件。</p><p><strong>总结</strong></p><ul><li><p>BF优点：<br>不需要存储数据本身，只用比特表示，因此空间占用相对于传统方式有巨大的优势，并且能够保密数据；<br>时间效率也较高，插入和查询的时间复杂度均为O(k)；<br>哈希函数之间相互独立，可以在硬件指令层面并行计算;</p></li><li><p>BF缺点：<br>只能插入和查询元素，不能删除元素，这与产生假阳性的原因是相同的;<br>存在假阳性的概率，不适用于任何要求100%准确率的情境；</p></li></ul><h4 id="假阳性概率的计算"><a href="#假阳性概率的计算" class="headerlink" title="假阳性概率的计算"></a>假阳性概率的计算</h4><p>那么在实际应用当中，如何来计算假阳性概率呢？这里给一个简单推导过程。</p><p>假设拿一个不存在于集合中的新元素，在已经插入n个元素，位数组长度为m，hash函数有k个的BF中进行存在性判断：</p><ol><li>位数组中某一特定的位在进行元素插入时的 Hash 操作中没有被置位的概率是：1-1/m</li><li>在所有k次Hash操作后该位都没有被置1的概率是: (1-1/m)^k</li><li>如果我们插入了 n 个元素，那么某一位仍然为 “0” 的概率是：(1-1/m)^kn</li><li>该位为1,即被置位的概率是:1-(1-1/m)^kn</li><li>经过k次Hash操作，每次对应的位置均为1（即假阳性）概率为: (1-(1-1/m)^kn)^k</li></ol><p>然后根据极限推导，可以得到如下公式：</p><p><img src="/images/5.png" alt="假阳性概率公式"></p><p>其中：</p><p>e:常数<br>n:插入元素的个数<br>m:bit数组的长度<br>k:哈希函数个数<br>并且有如下结论：对于给定的m和n，k=m*ln2/n 时，假阳性的概率取值最小，也就是说并不见得哈希函数个数越多，假阳性概率就越低，而是有个最优解。</p><img src="/images/6.png" alt="假阳性概率对照表" style="zoom:67%;" /><h3 id="redis对bloomFilter的支持"><a href="#redis对bloomFilter的支持" class="headerlink" title="redis对bloomFilter的支持"></a>redis对bloomFilter的支持</h3><p>redis没有直接提供BF等数据结构的支持，而是在<a href="https://redis.io/modules">Redis Modules</a>中提供了支持。通过下载<a href="https://github.com/RedisBloom/RedisBloom">RedisBloom</a>源码，编译后得到对应的so文件，然后在启动server加载这个so，就可以支持BF以及cuckoo filters和top-k等数据结构了。</p><p>安装RedisBloom</p><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/RedisBloom/</span>RedisBloom.gitcd RedisBloommake <span class="hljs-comment">#编译之后得到redisbloom.so文件</span><span class="hljs-comment">#然后通过--loadmodule加载即可</span>.<span class="hljs-regexp">/redis-server --loadmodule ../</span>redisbloom.so</code></pre><p>然后可以通过：<code>BF.ADD newFilter foo</code> 以及<code>BF.EXISTS newFilter foo</code>命令来添加元素和判断元素是否在集合当中。</p><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; BF.ADD test <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; BF.ADD test <span class="hljs-number">2</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; BF.ADD test <span class="hljs-number">3</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; BF.EXISTS test <span class="hljs-number">1</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; BF.EXISTS test <span class="hljs-number">4</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; BF.EXISTS test <span class="hljs-number">5</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt;</code></pre><p>此外，RedisBloom还提供一系列的客户端来支持不同的编程语言，比如我们可以通过python脚本来验证BF的假阳性概率是否在指定的范围内。可以先通过pip安装redisbloom客户端：<code>pip install redis redisbloom</code>，然后执行测试脚本。</p><pre><code class="hljs python"><span class="hljs-comment"># Using Bloom Filter</span><span class="hljs-keyword">from</span> redisbloom.client <span class="hljs-keyword">import</span> Client<span class="hljs-keyword">import</span> uuidTEST_KEY = <span class="hljs-string">&#x27;bloom&#x27;</span>rb = Client()<span class="hljs-comment"># do clean</span>rb.delete(TEST_KEY)<span class="hljs-comment"># 指定假阳性概率和m数组的长度</span>rb.bfCreate(TEST_KEY, <span class="hljs-number">0.05</span>, <span class="hljs-number">10000</span>) <span class="hljs-comment"># do test</span><span class="hljs-comment"># 添加10000个整数</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10000</span>):    <span class="hljs-comment">#uuid_str = str(uuid.uuid1()) + &quot;-&quot; + str(i)</span>    rb.bfAdd(TEST_KEY, i)error_count = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10001</span>, <span class="hljs-number">20000</span>):    <span class="hljs-keyword">if</span> rb.bfExists(TEST_KEY, i):        <span class="hljs-comment"># 如果存在肯定是出错了，即产生False Positive</span>        print(<span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&quot; exists...&quot;</span>)        error_count = error_count + <span class="hljs-number">1</span>    <span class="hljs-keyword">else</span>:        print(<span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&quot; not exists...&quot;</span>)print(<span class="hljs-string">&quot;false positive[error count:&quot;</span> + <span class="hljs-built_in">str</span>(error_count) + <span class="hljs-string">&quot; error rate: &quot;</span> + <span class="hljs-built_in">str</span>(<span class="hljs-built_in">format</span>(<span class="hljs-built_in">float</span>(error_count) / <span class="hljs-built_in">float</span>(<span class="hljs-number">10000</span>), <span class="hljs-string">&#x27;.2f&#x27;</span>)) + <span class="hljs-string">&quot;]&quot;</span>)</code></pre><p>输出结果：</p><pre><code class="hljs xquery">...<span class="hljs-number">19953</span><span class="hljs-built_in"> not</span><span class="hljs-built_in"> exists</span>...<span class="hljs-number">19954</span><span class="hljs-built_in"> exists</span>...<span class="hljs-number">19955</span><span class="hljs-built_in"> not</span><span class="hljs-built_in"> exists</span>......<span class="hljs-number">19998</span><span class="hljs-built_in"> not</span><span class="hljs-built_in"> exists</span>...<span class="hljs-number">19999</span><span class="hljs-built_in"> not</span><span class="hljs-built_in"> exists</span>...false positive<span class="hljs-built_in">[error</span><span class="hljs-built_in"> count</span>:<span class="hljs-number">256</span><span class="hljs-built_in"> error</span> rate: <span class="hljs-number">0</span>.<span class="hljs-number">03</span>]</code></pre><p>实际计算假阳性概率约为0.03。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>redis中的bitmap提供了一些直接操作字符串bit位的api，这类api能够很方便的在实际开发中解决很多问题。而redisbloom这个模块，使得redis真正支持布隆过滤器，以及支持删除的cuckoo filter。这类功能，在某些领域具有很大应用价值；在使用布隆过滤器的场景中，一定要考虑假阳性概率的情况，看看业务上是否能够容忍假阳性事件的出现。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html">http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html</a></p><p><a href="http://sigmodrecord.org/publications/sigmodRecord/0603/p26-article-pey.pdf">http://sigmodrecord.org/publications/sigmodRecord/0603/p26-article-pey.pdf</a></p><p><a href="https://redis.io/modules">https://redis.io/modules</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;除了常见的五种数据类型之外，在redis的高版本中，开始支持一些相对高级的数据结构；下面介绍一下redis中的位图（bitmap）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;bitmap&quot;&gt;&lt;a href=&quot;#bitmap&quot; class</summary>
      
    
    
    
    <category term="redis" scheme="http://heqiao2010.github.io/categories/redis/"/>
    
    
    <category term="bitmap" scheme="http://heqiao2010.github.io/tags/bitmap/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security 如何优雅的过滤掉静态页面请求</title>
    <link href="http://heqiao2010.github.io/2020/06/30/Spring_Security%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%87%E6%BB%A4%E6%8E%89%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82/"/>
    <id>http://heqiao2010.github.io/2020/06/30/Spring_Security%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%87%E6%BB%A4%E6%8E%89%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82/</id>
    <published>2020-06-30T10:00:00.000Z</published>
    <updated>2021-08-14T12:30:42.097Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在最近的开发过程中遇到一个问题，某个java服务采用spring security开启了认证，但是同时又需要采用swagger生成在线api文档，如果从这些请求中过滤掉swagger的请求成了一个问题。</p></blockquote><p>想到的方法一,用正则过滤：</p><pre><code class="hljs scala"><span class="hljs-meta">@EnableWebSecurity</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void configure(<span class="hljs-type">HttpSecurity</span> http) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;        http.csrf().disable();        http.sessionManagement().sessionCreationPolicy(<span class="hljs-type">SessionCreationPolicy</span>.<span class="hljs-type">STATELESS</span>);        http.authorizeRequests()                .antMatchers(<span class="hljs-string">&quot;/xxx/!?(doc.html|v2/api-docs|springfox.js|swagger-ui.html|swagger-resources|webjars)**&quot;</span>).authenticated();        http.addFilterBefore(authenticationFilter(), <span class="hljs-type">UsernamePasswordAuthenticationFilter</span>.<span class="hljs-keyword">class</span>);        http.exceptionHandling().authenticationEntryPoint(<span class="hljs-keyword">new</span> <span class="hljs-type">ComIdAuthenticationEntryPoint</span>());    &#125;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>更优雅的方法二，把Swagger的请求当做静态页面请求处理：</p><pre><code class="hljs scala"><span class="hljs-meta">@EnableWebSecurity</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt; <span class="hljs-type">PERMIT_URL_LIST</span> = <span class="hljs-type">ImmutableList</span>.of(            <span class="hljs-string">&quot;/xxx/doc.html*&quot;</span>,            <span class="hljs-string">&quot;/xxx/v2/api-docs/**&quot;</span>,            <span class="hljs-string">&quot;/xxx/springfox.js*&quot;</span>,            <span class="hljs-string">&quot;/xxx/swagger-ui.html*&quot;</span>,            <span class="hljs-string">&quot;/xxx/swagger-resources/**&quot;</span>,            <span class="hljs-string">&quot;/xxx/webjars/**&quot;</span>);    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void configure(<span class="hljs-type">HttpSecurity</span> http) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;        http.csrf().disable();        http.sessionManagement().sessionCreationPolicy(<span class="hljs-type">SessionCreationPolicy</span>.<span class="hljs-type">STATELESS</span>);        http.authorizeRequests()                .antMatchers(<span class="hljs-string">&quot;/xxx/**&quot;</span>).authenticated();        http.addFilterBefore(authenticationFilter(), <span class="hljs-type">UsernamePasswordAuthenticationFilter</span>.<span class="hljs-keyword">class</span>);        http.exceptionHandling().authenticationEntryPoint(<span class="hljs-keyword">new</span> <span class="hljs-type">ComIdAuthenticationEntryPoint</span>());    &#125;    <span class="hljs-meta">@Override</span>    public void configure(<span class="hljs-type">WebSecurity</span> web) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;        web.ignoring().antMatchers(<span class="hljs-type">PERMIT_URL_LIST</span>.toArray(<span class="hljs-keyword">new</span> <span class="hljs-type">String</span>[<span class="hljs-number">0</span>]));    &#125;    <span class="hljs-comment">// ...</span>&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在最近的开发过程中遇到一个问题，某个java服务采用spring security开启了认证，但是同时又需要采用swagger生成在线api文档，如果从这些请求中过滤掉swagger的请求成了一个问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想</summary>
      
    
    
    
    <category term="Spring" scheme="http://heqiao2010.github.io/categories/Spring/"/>
    
    
  </entry>
  
  <entry>
    <title>日志归档工具logrotate介绍</title>
    <link href="http://heqiao2010.github.io/2020/06/17/%E5%BF%97%E5%BD%92%E6%A1%A3%E5%B7%A5%E5%85%B7logrotate%E4%BB%8B%E7%BB%8D/"/>
    <id>http://heqiao2010.github.io/2020/06/17/%E5%BF%97%E5%BD%92%E6%A1%A3%E5%B7%A5%E5%85%B7logrotate%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-06-17T10:00:00.000Z</published>
    <updated>2021-08-14T12:30:40.961Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>对于日志的归档，轮转以及清理，很多框架都已经支持，比如logback，log4j等，对于logrotate鲜有用武之地。</p><p>不过最近做一个项目的时候，客户环境存在大量的syslog，但是对这类syslog日志确没有做定时的清理和归档，于是看了下centos自带的logrotate工具，还是蛮方便的。</p><h3 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h3><p>希望能够做到日志轮转，保留一周的日志，每天的日志保存到一个文件中，一周之前的日志，自动删除；2天之前的日志能够归档压缩；</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>在/etc/logrotate.d/目录新增logrotate配置，例如：<br>cat /etc/logrotate.d/test</p><pre><code class="hljs perl">/data/<span class="hljs-keyword">log</span>/test.log &#123;        daily    <span class="hljs-comment">#每天执行</span>        missingok <span class="hljs-comment"># 如果日志不存在，则忽略</span>        rotate <span class="hljs-number">7</span>  <span class="hljs-comment"># 保留7天的日志</span>        create <span class="hljs-number">644</span> root root  <span class="hljs-comment"># 新创建文件权限</span>        dateext  <span class="hljs-comment"># 用日期作为文件名后缀</span>        dateformat -%Y%m%d.%s <span class="hljs-comment">#日期格式</span>        nocompress  <span class="hljs-comment">#不需要压缩，compress 表示用gzip压缩</span>        copytruncate <span class="hljs-comment">#采用拷贝后截断的方式，归档日志，好处是避免日志归档对正在写这个log的程序出现问题 </span>&#125;</code></pre><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.huoding.com/2013/04/21/246">https://blog.huoding.com/2013/04/21/246</a></p><p><a href="https://linux.die.net/man/8/logrotate">https://linux.die.net/man/8/logrotate</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h3&gt;&lt;p&gt;对于日志的归档，轮转以及清理，很多框架都已经支持，比如logback，log4j等，对于logrotate鲜有用武之地。&lt;/p&gt;
&lt;p&gt;不过</summary>
      
    
    
    
    <category term="logrotate" scheme="http://heqiao2010.github.io/categories/logrotate/"/>
    
    
  </entry>
  
  <entry>
    <title>Freemarker中如何进行Json转化</title>
    <link href="http://heqiao2010.github.io/2019/07/26/Freemarker%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8CJson%E8%BD%AC%E5%8C%96/"/>
    <id>http://heqiao2010.github.io/2019/07/26/Freemarker%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8CJson%E8%BD%AC%E5%8C%96/</id>
    <published>2019-07-26T10:00:00.000Z</published>
    <updated>2021-08-14T12:30:40.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><p>之前在开发过程中,freemarker的解析经常遇见一些问题,这里将这些问题做一下记录.</p><p>比如,如下错误,是因为freemarker模板中出现了一个全角的中文空格,导致解析出现失败.</p><pre><code class="hljs groovy"><span class="hljs-attr">Error:</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-attr">java:</span> 非法字符: <span class="hljs-string">&#x27;\ufeff&#x27;</span></code></pre><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>需求是,从freemarker中构造出一个Json,然后将这个json进行url编码,放到一个url后面,用户点击这个url,则立即可以跳转到指定的页面,页面再根据这个参数做相应的解析.</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在freemarker中,是通过拼凑Json字段进行处理的.在拼凑Json字段的过程中,会涉及字段的转义:</p><pre><code class="hljs csharp"><span class="hljs-keyword">event</span>.<span class="hljs-keyword">params</span>.<span class="hljs-keyword">group</span>?j_string</code></pre><p>以及urlencode:</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">#assign</span> <span class="hljs-attr">url_param</span>=<span class="hljs-string">&quot;search=$</span></span></span><span class="hljs-template-variable">&#123;search?url&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span> /&gt;</span></span></code></pre><p>还有特别重要的是,有些字段需要判空,判空有好几种形式:</p><pre><code class="hljs clean">&lt;#--条件判空--&gt;&lt;#<span class="hljs-keyword">if</span> event.params.processName?? &gt;            &lt;#assign processName = event.params.processName?j_string /&gt; &lt;/#<span class="hljs-keyword">if</span>&gt; &lt;#--感叹号判空--&gt;&lt;#assign filePath = (event.params.filePath!<span class="hljs-string">&quot;&quot;</span>)?j_string /&gt;&lt;#--为空,则展示为空串--&gt;$&#123;(grouplist)!&#125;</code></pre><p>整体例子:</p><pre><code class="hljs smalltalk">&lt;<span class="hljs-symbol">#macro</span> detailLinkParams aggregateAgentEvents&gt;        &lt;<span class="hljs-symbol">#setting</span> url_escaping_charset=<span class="hljs-string">&#x27;utf8&#x27;</span>/&gt;        &lt;<span class="hljs-symbol">#if</span> (aggregateAgentEvents?size&gt;<span class="hljs-number">0</span>) &gt; &lt;#--连接进程--&gt;&lt;<span class="hljs-symbol">#assign</span> processName=<span class="hljs-comment">&quot;&quot;</span> /&gt;&lt;#--业务组--&gt;&lt;<span class="hljs-symbol">#assign</span> group=[] /&gt;&lt;#--主机名--&gt;&lt;<span class="hljs-symbol">#assign</span> hostname=<span class="hljs-comment">&quot;&quot;</span> /&gt;&lt;#--端口--&gt;&lt;<span class="hljs-symbol">#assign</span> targetPort=<span class="hljs-comment">&quot;&quot;</span> /&gt;&lt;#--目标主机--&gt;&lt;<span class="hljs-symbol">#assign</span> targetIpLike=<span class="hljs-comment">&quot;&quot;</span> /&gt;&lt;#--主机<span class="hljs-type">IP</span>--&gt;&lt;<span class="hljs-symbol">#assign</span> ip=<span class="hljs-comment">&quot;&quot;</span> /&gt;&lt;#--时间区间--&gt;&lt;<span class="hljs-symbol">#assign</span> time_max = aggregateAgentEvents[<span class="hljs-number">0</span>].params.dataTime/&gt;&lt;<span class="hljs-symbol">#assign</span> time_min = aggregateAgentEvents[<span class="hljs-number">0</span>].params.dataTime/&gt;                &lt;<span class="hljs-symbol">#list</span> aggregateAgentEvents as event&gt;      &lt;<span class="hljs-symbol">#if</span> event.params.group?? &amp;&amp; !(group?seq_contains(event.params.group?j_string)) &gt;      &lt;<span class="hljs-symbol">#assign</span> group = group + [event.params.group?j_string] /&gt;     &lt;/<span class="hljs-symbol">#if</span>&gt;      &lt;<span class="hljs-symbol">#if</span> event.params.processName?? &gt;            &lt;<span class="hljs-symbol">#assign</span> processName = event.params.processName?j_string /&gt;      &lt;/<span class="hljs-symbol">#if</span>&gt;              &lt;<span class="hljs-symbol">#if</span> event.params.hostname?? &gt;                   &lt;<span class="hljs-symbol">#assign</span> hostname = event.params.hostname?j_string /&gt;       &lt;/<span class="hljs-symbol">#if</span>&gt;     &lt;<span class="hljs-symbol">#if</span> event.params.targetPort?? &gt;         &lt;<span class="hljs-symbol">#assign</span> targetPort = event.params.targetPort?j_string /&gt;     &lt;/<span class="hljs-symbol">#if</span>&gt;     &lt;<span class="hljs-symbol">#if</span> event.params.targetIp?? &gt;         &lt;<span class="hljs-symbol">#assign</span> targetIpLike = event.params.targetIp?j_string /&gt;     &lt;/<span class="hljs-symbol">#if</span>&gt;     &lt;<span class="hljs-symbol">#if</span> event.params.displayIp?? &gt;         &lt;<span class="hljs-symbol">#assign</span> ip = event.params.displayIp?j_string /&gt;     &lt;/<span class="hljs-symbol">#if</span>&gt;     &lt;<span class="hljs-symbol">#if</span> (time_max &lt; event.params.dataTime) &gt;                            &lt;<span class="hljs-symbol">#assign</span> time_max = event.params.dataTime /&gt;                     &lt;/<span class="hljs-symbol">#if</span>&gt;                     &lt;<span class="hljs-symbol">#if</span> (time_min &gt; event.params.dataTime) &gt;                            &lt;<span class="hljs-symbol">#assign</span> time_min = event.params.dataTime /&gt;                     &lt;/<span class="hljs-symbol">#if</span>&gt;                &lt;/<span class="hljs-symbol">#list</span>&gt;                &lt;<span class="hljs-symbol">#assign</span> time_max = time_max + <span class="hljs-number">1</span>/&gt;&lt;<span class="hljs-symbol">#assign</span> time_min = time_min - <span class="hljs-number">1</span>/&gt;                &lt;<span class="hljs-symbol">#assign</span> time=<span class="hljs-comment">&quot;&#123;\&quot;</span>min\<span class="hljs-comment">&quot;:\&quot;</span><span class="hljs-string">$&#123;</span>(time_min*<span class="hljs-number">1000</span>)?number_to_datetime?string(<span class="hljs-string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>)&#125;\<span class="hljs-comment">&quot;,\&quot;</span>max\<span class="hljs-comment">&quot;:\&quot;</span><span class="hljs-string">$&#123;</span>(time_max*<span class="hljs-number">1000</span>)?number_to_datetime?string(<span class="hljs-string">&#x27;yyyy-MM-dd HH:mm:ss&#x27;</span>)&#125;\<span class="hljs-comment">&quot;&#125;&quot;</span>/&gt;                &lt;<span class="hljs-symbol">#assign</span> grouplist = group?join(<span class="hljs-comment">&quot;,&quot;</span>) /&gt;&lt;<span class="hljs-symbol">#if</span> (aggregateAgentEvents?size==<span class="hljs-number">1</span>) &gt;&lt;<span class="hljs-symbol">#assign</span> search=<span class="hljs-comment">&quot;&#123;\&quot;</span>processName\<span class="hljs-comment">&quot;:\&quot;</span><span class="hljs-string">$&#123;</span>(processName)!&#125;\<span class="hljs-comment">&quot;,\&quot;</span>createTime\<span class="hljs-comment">&quot;:$&#123;time&#125;,\&quot;</span>group\<span class="hljs-comment">&quot;:[$&#123;(grouplist)!&#125;],\&quot;</span>ip\<span class="hljs-comment">&quot;:\&quot;</span><span class="hljs-string">$&#123;</span>(ip)!&#125;\<span class="hljs-comment">&quot;,\&quot;</span>targetIpLike\<span class="hljs-comment">&quot;:\&quot;</span><span class="hljs-string">$&#123;</span>(targetIpLike)!&#125;\<span class="hljs-comment">&quot;,\&quot;</span>targetPort\<span class="hljs-comment">&quot;:$&#123;(targetPort)!&#125;,\&quot;</span>hostname\<span class="hljs-comment">&quot;:\&quot;</span><span class="hljs-string">$&#123;</span>(hostname)!&#125;\<span class="hljs-comment">&quot;&#125;&quot;</span>/&gt;&lt;<span class="hljs-symbol">#else</span>&gt;&lt;<span class="hljs-symbol">#assign</span> search=<span class="hljs-comment">&quot;&#123;\&quot;</span>processName\<span class="hljs-comment">&quot;:\&quot;</span><span class="hljs-string">$&#123;</span>(processName)!&#125;\<span class="hljs-comment">&quot;,\&quot;</span>createTime\<span class="hljs-comment">&quot;:$&#123;time&#125;,\&quot;</span>group\<span class="hljs-comment">&quot;:[$&#123;(grouplist)!&#125;],\&quot;</span>ip\<span class="hljs-comment">&quot;:\&quot;</span><span class="hljs-string">$&#123;</span>(ip)!&#125;\<span class="hljs-comment">&quot;,\&quot;</span>targetIpLike\<span class="hljs-comment">&quot;:\&quot;</span><span class="hljs-string">$&#123;</span>(targetIpLike)!&#125;\<span class="hljs-comment">&quot;,\&quot;</span>targetPort\<span class="hljs-comment">&quot;:$&#123;(targetPort)!&#125;,\&quot;</span>hostname\<span class="hljs-comment">&quot;:\&quot;</span><span class="hljs-string">$&#123;</span>(hostname)!&#125;\<span class="hljs-comment">&quot;&#125;&quot;</span>/&gt;&lt;/<span class="hljs-symbol">#if</span>&gt;                &lt;<span class="hljs-symbol">#assign</span> url_param=<span class="hljs-comment">&quot;search=$&#123;search?url&#125;&quot;</span> /&gt;&lt;<span class="hljs-symbol">#else</span>&gt;&lt;<span class="hljs-symbol">#assign</span> url_param=<span class="hljs-comment">&quot;a=1&quot;</span>/&gt;&lt;/<span class="hljs-symbol">#if</span>&gt;<span class="hljs-string">$&#123;</span>url_param&#125;&lt;/<span class="hljs-symbol">#macro</span>&gt;</code></pre><h3 id="额外的问题"><a href="#额外的问题" class="headerlink" title="额外的问题"></a>额外的问题</h3><p>FreeMarker遍历集合集合时貌似有个要求，集合本身必须是Collection的子类；如果将jackson的JsonNode对象，扔给Freemarker则可能会有问题，例如：</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;vuls&quot;</span>: [        &#123;            <span class="hljs-attr">&quot;vuln&quot;</span>: <span class="hljs-number">1</span>,            <span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">6379</span>,            <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span>,            <span class="hljs-attr">&quot;checkid&quot;</span>: <span class="hljs-number">7</span>,            <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;xxx!&quot;</span>,            <span class="hljs-attr">&quot;hacked_file&quot;</span>: [                &#123;                    <span class="hljs-attr">&quot;info&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span>,                    <span class="hljs-attr">&quot;path&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span>                &#125;            ],            <span class="hljs-attr">&quot;pid&quot;</span>: <span class="hljs-number">1351</span>        &#125;]&#125;</code></pre><p>如果通过如下模板进行解析，则会出现问题，因为json对象中的数组，无法用freemarker中的list遍历，这点很奇怪。</p><pre><code class="hljs stata">XXX ：&lt;#<span class="hljs-keyword">list</span> vuls <span class="hljs-keyword">as</span> vul&gt; &lt;#<span class="hljs-keyword">list</span> vul.hacked_file <span class="hljs-keyword">as</span> item&gt;  xx：<span class="hljs-variable">$&#123;item</span>.path&#125;,xxx：<span class="hljs-variable">$&#123;item</span>.info&#125; &lt;/#<span class="hljs-keyword">list</span>&gt;&lt;/#<span class="hljs-keyword">list</span>&gt;</code></pre><p>但是可以通过把JsonNode当做字符串处理，在freemarker中用eval进行处理，则没问题：</p><pre><code class="hljs clean">&lt;#function parseJSON json&gt;  &lt;#local null = <span class="hljs-string">&#x27;null&#x27;</span>&gt; &lt;#-- null is not a keyword <span class="hljs-keyword">in</span> FTL --&gt;  &lt;#return json?eval&gt;&lt;/#function&gt;&lt;#assign jsonObj=parseJSON(vuls)/&gt;XXX ：&lt;#list jsonObj <span class="hljs-keyword">as</span> vul&gt; &lt;#list vul.hacked_file <span class="hljs-keyword">as</span> item&gt;  xx：$&#123;item.path&#125;,xxx：$&#123;item.info&#125; &lt;/#list&gt;&lt;/#list&gt;</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://stackoverflow.com/questions/46154391/how-can-i-iterate-a-collection-twice-in-freemarker#">https://stackoverflow.com/questions/46154391/how-can-i-iterate-a-collection-twice-in-freemarker#</a></p><p><a href="https://stackoverflow.com/questions/17778844/evaluate-json-with-null-value-using-freemarker">https://stackoverflow.com/questions/17778844/evaluate-json-with-null-value-using-freemarker</a></p><p><a href="https://stackoverflow.com/questions/12708162/how-to-get-json-into-a-freemarker-template-ftl">https://stackoverflow.com/questions/12708162/how-to-get-json-into-a-freemarker-template-ftl</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h3&gt;&lt;p&gt;之前在开发过程中,freemarker的解析经常遇见一些问题,这里将这些问题做一下记录.&lt;/p&gt;
&lt;p&gt;比如,如下错误,是因为freemar</summary>
      
    
    
    
    <category term="Freemarker" scheme="http://heqiao2010.github.io/categories/Freemarker/"/>
    
    
    <category term="Freemarker" scheme="http://heqiao2010.github.io/tags/Freemarker/"/>
    
  </entry>
  
  <entry>
    <title>ControllerAdvice注解</title>
    <link href="http://heqiao2010.github.io/2019/07/08/ControllerAdvice%E6%B3%A8%E8%A7%A3/"/>
    <id>http://heqiao2010.github.io/2019/07/08/ControllerAdvice%E6%B3%A8%E8%A7%A3/</id>
    <published>2019-07-08T10:00:00.000Z</published>
    <updated>2021-08-14T12:30:41.773Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>准确的来说,这个是springmvc中的一个注解.<br>从Advice后缀可以看出,这个注解是针对Controller的一个增强.在对外提供Http接口支持的时候,往往有很多通用的业务逻辑.最常见的是同样的异常处理逻辑.<br>为了避免大块的try-catch块的出现,可以通过此注解提供一个异常处理的增强来解决.</p><h4 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h4><p>在ControllerAdvice类中标注某个方法,用于处理某个类型的异常.</p><p>例子:</p><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 统一处理网关接口异常</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Created by qiaohe on 19-6-27.</span><span class="hljs-comment"> */</span>@Component@<span class="hljs-constructor">ControllerAdvice(<span class="hljs-string">&quot;com.*&quot;</span>)</span>public <span class="hljs-keyword">class</span> ExceptionAdvice &#123;    <span class="hljs-keyword">private</span> final Logger logger = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LoggerFactory</span>.</span></span>get<span class="hljs-constructor">Logger(ExceptionAdvice.<span class="hljs-params">class</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 处理AuthFailedException</span><span class="hljs-comment">     */</span>    @<span class="hljs-constructor">ExceptionHandler(AuthFailedException.<span class="hljs-params">class</span>)</span>    @ResponseBody    public BaseResult handle<span class="hljs-constructor">Exception(AuthFailedException <span class="hljs-params">ex</span>)</span>&#123;        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BaseResult</span>.</span></span>failure(ex.get<span class="hljs-constructor">AuthFailedCode()</span>.get<span class="hljs-constructor">Code()</span>,                ex.get<span class="hljs-constructor">AuthFailedCode()</span>.get<span class="hljs-constructor">Desc()</span>);    &#125;&#125;</code></pre><h4 id="其他两个不常用的注解"><a href="#其他两个不常用的注解" class="headerlink" title="其他两个不常用的注解"></a>其他两个不常用的注解</h4><p>@InitBinder：用来设置WebDataBinder，用于自动绑定前台请求参数到Model中。</p><p>@ModelAttribute：本来作用是绑定键值对到Model中，此处让全局的@RequestMapping都能获得在此处设置的键值对。</p><p>列子:</p><pre><code class="hljs reasonml">@<span class="hljs-constructor">ControllerAdvice(<span class="hljs-params">basePackages</span> = &#123;<span class="hljs-string">&quot;com.concretepage.controller&quot;</span>&#125; )</span>public <span class="hljs-keyword">class</span> GlobalControllerAdvice &#123;@InitBinderpublic void data<span class="hljs-constructor">Binding(WebDataBinder <span class="hljs-params">binder</span>)</span> &#123;SimpleDateFormat dateFormat = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SimpleDateFormat(<span class="hljs-string">&quot;dd/MM/yyyy&quot;</span>)</span>;dateFormat.set<span class="hljs-constructor">Lenient(<span class="hljs-params">false</span>)</span>;binder.register<span class="hljs-constructor">CustomEditor(Date.<span class="hljs-params">class</span>, <span class="hljs-string">&quot;dob&quot;</span>, <span class="hljs-params">new</span> CustomDateEditor(<span class="hljs-params">dateFormat</span>, <span class="hljs-params">true</span>)</span>);&#125;@ModelAttribute        public void global<span class="hljs-constructor">Attributes(Model <span class="hljs-params">model</span>)</span> &#123;model.add<span class="hljs-constructor">Attribute(<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;Welcome to My World!&quot;</span>)</span>;        &#125;@<span class="hljs-constructor">ExceptionHandler(FileNotFoundException.<span class="hljs-params">class</span>)</span>        public ModelAndView my<span class="hljs-constructor">Error(Exception <span class="hljs-params">exception</span>)</span> &#123;    ModelAndView mav = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ModelAndView()</span>;    mav.add<span class="hljs-constructor">Object(<span class="hljs-string">&quot;exception&quot;</span>, <span class="hljs-params">exception</span>)</span>;    mav.set<span class="hljs-constructor">ViewName(<span class="hljs-string">&quot;error&quot;</span>)</span>;    return mav;&#125;&#125;</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.concretepage.com/spring/spring-mvc/spring-mvc-controlleradvice-annotation-example">https://www.concretepage.com/spring/spring-mvc/spring-mvc-controlleradvice-annotation-example</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;基本功能&quot;&gt;&lt;a href=&quot;#基本功能&quot; class=&quot;headerlink&quot; title=&quot;基本功能&quot;&gt;&lt;/a&gt;基本功能&lt;/h3&gt;&lt;p&gt;准确的来说,这个是springmvc中的一个注解.&lt;br&gt;从Advice后缀可以看出,这个注解是针对Controller的一</summary>
      
    
    
    
    <category term="Spring" scheme="http://heqiao2010.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://heqiao2010.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习之Profile和Lookup注解</title>
    <link href="http://heqiao2010.github.io/2019/07/02/Spring%E5%AD%A6%E4%B9%A0%E4%B9%8BProfile%E5%92%8CLookup%E6%B3%A8%E8%A7%A3/"/>
    <id>http://heqiao2010.github.io/2019/07/02/Spring%E5%AD%A6%E4%B9%A0%E4%B9%8BProfile%E5%92%8CLookup%E6%B3%A8%E8%A7%A3/</id>
    <published>2019-07-02T10:00:00.000Z</published>
    <updated>2021-08-14T12:30:41.321Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在编码过程中遇到一个Profile和Lookup注解的问题,这里记录一下.Profile的原意是剖面的意思,Profile在官方的API文档中,是如此描述的:</p></blockquote><blockquote><p>A profile is a named logical grouping that may be activated programmatically via ConfigurableEnvironment.setActiveProfiles(java.lang.String…) or declaratively by setting the spring.profiles.active property as a JVM system property, as an environment variable, or as a Servlet context parameter in web.xml for web applications. Profiles may also be activated declaratively in integration tests via the @ActiveProfiles annotation.</p></blockquote><blockquote><p>通过Profile可以从逻辑上对Bean做一些分组,然后应用中通过配置来选中某一组Bean进行实例化.Lookup注解是用于实现,注入prototype-scoped类型的Bean,一般我们可能习惯用new的方式去实例化非单例模式的Bean.</p></blockquote><h3 id="Profile注解示例"><a href="#Profile注解示例" class="headerlink" title="Profile注解示例"></a>Profile注解示例</h3><p>实现开发环境和生产环境采用不同的数据源.</p><pre><code class="hljs java"><span class="hljs-comment">// 开发环境采用mysql数据库</span><span class="hljs-meta">@Profile(&quot;Development&quot;)</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DevDatabaseConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DatabaseConfig</span> </span>&#123;     <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">createDataSource</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Creating DEV database&quot;</span>);        DriverManagerDataSource dataSource = <span class="hljs-keyword">new</span> DriverManagerDataSource();        <span class="hljs-comment">/*</span><span class="hljs-comment">         * Set MySQL specific properties for Development Environment</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">return</span> dataSource;    &#125; &#125;<span class="hljs-comment">// 生产环境采用Oracle数据库</span><span class="hljs-meta">@Profile(&quot;Production&quot;)</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductionDatabaseConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DatabaseConfig</span> </span>&#123;     <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">createDataSource</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">&quot;Creating Production database&quot;</span>);        DriverManagerDataSource dataSource = <span class="hljs-keyword">new</span> DriverManagerDataSource();        <span class="hljs-comment">/*</span><span class="hljs-comment">         * Set ORACLE specific properties for Production environment</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">return</span> dataSource;    &#125; &#125;</code></pre><p>除了采用注解,使用配置文件也可以达到同样的效果.</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">&quot;Development&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;dev-config-context.xml&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">&quot;Production&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;prod-config-context.xml&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre><p>测试:</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppMain</span> &#123;</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span> args[])</span></span>&#123;        AnnotationConfigApplicationContext  context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();        <span class="hljs-comment">//Sets the active profiles</span>        context.getEnvironment().setActiveProfiles(<span class="hljs-string">&quot;Development&quot;</span>);        <span class="hljs-comment">//Scans the mentioned package[s] and register all the @Component available to Spring</span>        context.scan(<span class="hljs-string">&quot;com.websystique.spring&quot;</span>);         context.refresh();        context.<span class="hljs-built_in">close</span>();    &#125; &#125;</code></pre><h3 id="Lookup注解"><a href="#Lookup注解" class="headerlink" title="Lookup注解"></a>Lookup注解</h3><p>lookup可以实现方法注入,即利用lookup可以让某个单例Bean的某个方法每次都返回一个新的Bean,即prototype类型的Bean.这是依赖CGlib技术实现的,在运行时,修改字节码.</p><p>利用xml文件实现:</p><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;car&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.smart.injectfun.Car&quot;</span> p:<span class="hljs-attribute">brand</span>=<span class="hljs-string">&quot;红旗CA72&quot;</span>, p:<span class="hljs-attribute">price</span>=<span class="hljs-string">&quot;2000&quot;</span> <span class="hljs-attribute">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span> /&gt;&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;magicBoss&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;com.smart.injectfun.MagicBoss&quot;</span>&gt;    &lt;look-method <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;getCar&quot;</span> <span class="hljs-attribute">bean</span>=<span class="hljs-string">&quot;car&quot;</span>&gt;&lt;bean&gt;</code></pre><p>也可以通过注解来实现:</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MagicBossIMpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MagicBoss</span> </span>&#123;    <span class="hljs-meta">@Lookup</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">getCar</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.baeldung.com/spring-lookup">https://www.baeldung.com/spring-lookup</a></p><p><a href="http://websystique.com/spring/spring-profile-example/">http://websystique.com/spring/spring-profile-example/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在编码过程中遇到一个Profile和Lookup注解的问题,这里记录一下.Profile的原意是剖面的意思,Profile在官方的API文档中,是如此描述的:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;A profile </summary>
      
    
    
    
    <category term="Spring" scheme="http://heqiao2010.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://heqiao2010.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java诊断工具Arthas之watch命令</title>
    <link href="http://heqiao2010.github.io/2019/07/01/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E4%B9%8Bwatch%E5%91%BD%E4%BB%A4/"/>
    <id>http://heqiao2010.github.io/2019/07/01/Java%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7Arthas%E4%B9%8Bwatch%E5%91%BD%E4%BB%A4/</id>
    <published>2019-07-01T10:00:00.000Z</published>
    <updated>2021-08-14T12:30:41.025Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Arthas是一个开源的Java诊断工具,详见:<a href="https://alibaba.github.io/arthas/index.html">https://alibaba.github.io/arthas/index.html</a>. 今天第一次在项目中排查问题使用到它,发现其功能确实很强大.这里记录一下watch命令的使用.</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装JDK然后以jar包的形式运行即可.</p><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//</span>alibaba.github.io<span class="hljs-regexp">/arthas/</span>arthas-boot.jarjava -jar arthas-boot.jar</code></pre><h3 id="利用watch诊断方法调用"><a href="#利用watch诊断方法调用" class="headerlink" title="利用watch诊断方法调用"></a>利用watch诊断方法调用</h3><p>通过Arthas的watch方法可以在没有打印日志的情况下,看到方法的入参和返回值.这点在没有打印debug或者重启会破坏现场的情况下是非常有用的。</p><p>在运行arthas-boot.jar之后，会列出当前系统中的所有java进程，然后输入需要诊断的进程的序号，就进入了arthas的命令模式了。这里以官网上的java -jar arthas-demo.jar为例，毕竟为了信息安全，把在公司的debug信息透出不大好。</p><ol><li><p>首先可以利用sc命令，查询对应的类名。</p><pre><code class="hljs angelscript">$ sc *Math*demo.MathGameio.netty.util.<span class="hljs-built_in">int</span>ernal.MathUtiljava.lang.MathAffect(row-cnt:<span class="hljs-number">3</span>) cost <span class="hljs-keyword">in</span> <span class="hljs-number">17</span> ms.</code></pre></li><li><p>然后再用sm命令，查询对应的方法。</p><pre><code class="hljs maxima">$ sm <span class="hljs-built_in">demo</span>.MathGame*<span class="hljs-built_in">demo</span>.MathGame &lt;init&gt;()V<span class="hljs-built_in">demo</span>.MathGame primeFactors(I)Ljava/util/List;<span class="hljs-built_in">demo</span>.MathGame main([Ljava/lang/String;)V<span class="hljs-built_in">demo</span>.MathGame run()V<span class="hljs-built_in">demo</span>.MathGame <span class="hljs-built_in">print</span>(ILjava/util/List;)VAffect(<span class="hljs-built_in">row</span>-cnt:<span class="hljs-number">5</span>) cost <span class="hljs-keyword">in</span> <span class="hljs-number">9</span> ms.</code></pre></li><li><p>利用watch命令，监听指定的方法，-x 参数可以指定打印入参和返回值的深度。</p></li></ol><pre><code class="hljs prolog">$ watch demo.<span class="hljs-symbol">MathGame</span> primeFactors <span class="hljs-string">&quot;&#123;params,returnObj&#125;&quot;</span> -x <span class="hljs-number">2</span><span class="hljs-symbol">Press</span> <span class="hljs-symbol">Q</span> or <span class="hljs-symbol">Ctrl</span>+<span class="hljs-symbol">C</span> to abort.<span class="hljs-symbol">Affect</span>(class-cnt:<span class="hljs-number">1</span> , method-cnt:<span class="hljs-number">1</span>) cost in <span class="hljs-number">49</span> ms.ts=<span class="hljs-number">2019</span><span class="hljs-number">-07</span><span class="hljs-number">-03</span> <span class="hljs-number">14</span>:<span class="hljs-number">29</span>:<span class="hljs-number">41</span>; [cost=<span class="hljs-number">1.778091</span>ms] result=@<span class="hljs-symbol">ArrayList</span>[    @<span class="hljs-symbol">Object</span>[][        @<span class="hljs-symbol">Integer</span>[<span class="hljs-number">-136776</span>],    ],    null,]ts=<span class="hljs-number">2019</span><span class="hljs-number">-07</span><span class="hljs-number">-03</span> <span class="hljs-number">14</span>:<span class="hljs-number">29</span>:<span class="hljs-number">42</span>; [cost=<span class="hljs-number">0.105508</span>ms] result=@<span class="hljs-symbol">ArrayList</span>[    @<span class="hljs-symbol">Object</span>[][        @<span class="hljs-symbol">Integer</span>[<span class="hljs-number">47524</span>],    ],    @<span class="hljs-symbol">ArrayList</span>[        @<span class="hljs-symbol">Integer</span>[<span class="hljs-number">2</span>],        @<span class="hljs-symbol">Integer</span>[<span class="hljs-number">2</span>],        @<span class="hljs-symbol">Integer</span>[<span class="hljs-number">109</span>],        @<span class="hljs-symbol">Integer</span>[<span class="hljs-number">109</span>],    ],]</code></pre><p>我就是利用这个工具，诊断出系统中一个很奇怪的问题。最终原因是因为PHP程序调用Java接口在时序上有略微的差异导致的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Arthas是一个开源的Java诊断工具,详见:&lt;a href=&quot;https://alibaba.github.io/arthas/index.html&quot;&gt;https://alibaba.github.io/arthas/index.html&lt;/a</summary>
      
    
    
    
    <category term="Arthas" scheme="http://heqiao2010.github.io/categories/Arthas/"/>
    
    
    <category term="Arthas" scheme="http://heqiao2010.github.io/tags/Arthas/"/>
    
  </entry>
  
  <entry>
    <title>JUC共享锁之Semaphore</title>
    <link href="http://heqiao2010.github.io/2019/06/24/JUC%E5%85%B1%E4%BA%AB%E9%94%81%E4%B9%8BSemaphore/"/>
    <id>http://heqiao2010.github.io/2019/06/24/JUC%E5%85%B1%E4%BA%AB%E9%94%81%E4%B9%8BSemaphore/</id>
    <published>2019-06-24T10:00:00.000Z</published>
    <updated>2021-08-14T12:30:42.821Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Semaphore原意是指信号量,从API的注释:”Semaphores are often used to restrict the number of threads than can access some (physical or logical) resource”可以看出,Semaphore一般是用来限制线程能够使用的资源个数.</p></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>在Web开发中,Semaphore可以用来限制某个接口的并发调用次数.可以在Sping的Context中维护一个Map,key可以是处理线程,value可以是一个Semaphore对象.通过这样的方式,就可以实现系统同时处理的线程数不会超过某个阈值.</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们可以通过WebFilter注解,来实现一个过滤器,在过滤器中拦截所有的请求调用,然后通过Semaphore来进行计数,如果超过总的计数,则返回相应的提示信息.当然也可以对URL进行细化,针对每个API提供对应的限制.</p><pre><code class="hljs aspectj"><span class="hljs-comment">/**</span><span class="hljs-comment"> * API并发控制过滤器</span><span class="hljs-comment"> * Created by qiaohe</span><span class="hljs-comment"> * Date: 19-7-1 上午11:54</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@WebFilter</span>(urlPatterns = <span class="hljs-string">&quot;/*&quot;</span>, filterName = <span class="hljs-string">&quot;concurrentRestrictFilter&quot;</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentRestrictFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;    <span class="hljs-keyword">private</span> Log log = LogFactory.getLog(getClass());    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer MAX_CONCURRENT_NUM = <span class="hljs-number">1</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(MAX_CONCURRENT_NUM);    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        log.info(<span class="hljs-string">&quot;before acquire: &quot;</span> + semaphore.availablePermits());        <span class="hljs-keyword">if</span>(!semaphore.tryAcquire())&#123;            <span class="hljs-keyword">if</span>(response <span class="hljs-keyword">instanceof</span> HttpServletResponse)&#123;                HttpServletResponse res = (HttpServletResponse)response;                res.setContentType(MimeTypeUtils.APPLICATION_JSON_VALUE);                res.sendError(HttpStatus.BAD_REQUEST.value(), <span class="hljs-string">&quot;reach max current num&quot;</span>);            &#125;            <span class="hljs-keyword">return</span>;        &#125;        log.info(<span class="hljs-string">&quot;after acquire: &quot;</span> + semaphore.availablePermits());        <span class="hljs-keyword">try</span>&#123;            chain.doFilter(request, response);        &#125; <span class="hljs-keyword">finally</span> &#123;            semaphore.release();            log.info(<span class="hljs-string">&quot;release: &quot;</span> + semaphore.availablePermits());        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Semaphore原意是指信号量,从API的注释:”Semaphores are often used to restrict the number of threads than can access some (physical or logi</summary>
      
    
    
    
    <category term="Java并发基础" scheme="http://heqiao2010.github.io/categories/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="http://heqiao2010.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>如何将jar包发布到中央仓库</title>
    <link href="http://heqiao2010.github.io/2019/06/21/%E5%A6%82%E4%BD%95%E5%B0%86jar%E5%8C%85%E5%8F%91%E5%B8%83%E5%88%B0%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93/"/>
    <id>http://heqiao2010.github.io/2019/06/21/%E5%A6%82%E4%BD%95%E5%B0%86jar%E5%8C%85%E5%8F%91%E5%B8%83%E5%88%B0%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93/</id>
    <published>2019-06-21T10:00:00.000Z</published>
    <updated>2021-08-14T12:30:43.565Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前在github上开发了一个简单的项目，一直想把这个jar包发布到中央仓库。一直没有时间弄这个，今天抽出点时间，按照网上的例子，操作了一遍，顺便记录一下，一遍将来参考。我的开发环境是ubuntu18.04，maven3，整个过程还是比较顺利的。</p></blockquote><h2 id="注册JIRA账号"><a href="#注册JIRA账号" class="headerlink" title="注册JIRA账号"></a>注册JIRA账号</h2><p>打开<a href="https://issues.sonatype.org/secure/Dashboard.jspa">https://issues.sonatype.org/secure/Dashboard.jspa</a> ，用邮箱注册即可。</p><h2 id="创建issue"><a href="#创建issue" class="headerlink" title="创建issue"></a>创建issue</h2><p>需要填写group id项目地址之类的，页面都有示例提示。</p><h2 id="等待审核"><a href="#等待审核" class="headerlink" title="等待审核"></a>等待审核</h2><p>提交的issue需要人工审核，审核之后，issue的状态变为：RESOLVED，到了这一步就可以上传jar包了。</p><h2 id="配置maven-Setting-xml文件"><a href="#配置maven-Setting-xml文件" class="headerlink" title="配置maven Setting.xml文件"></a>配置maven Setting.xml文件</h2><p>maven的Setting.xml文件可以在安装路径的conf目录下，也可以只修改当前用户<code>.m</code>目录下，如果你的电脑是多账户共享的话。在Settings.xml文件中，找到<code>&lt;servers&gt;</code>标签，然后在标签中增加如下配置：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>自行替换<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>替换成自己的JIRA账号<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>替换成自己的JIRA账号密码<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span></code></pre><p>id一般写oss就行。需要和pom文件中保持一致。</p><h2 id="修改pom文件"><a href="#修改pom文件" class="headerlink" title="修改pom文件"></a>修改pom文件</h2><p>我这次发布的pom文件内容如下：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.sonatype.oss<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>oss-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">licenses</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">license</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>The Apache Software License, Version 2.0<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://www.apache.org/licenses/LICENSE-2.0.txt<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">distribution</span>&gt;</span>repo<span class="hljs-tag">&lt;/<span class="hljs-name">distribution</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">license</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">licenses</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scm</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://github.com/heqiao2010<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">connection</span>&gt;</span>https://github.com/heqiao2010/LunarCalendar.git<span class="hljs-tag">&lt;/<span class="hljs-name">connection</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">scm</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">developers</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">developer</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Joel Herb<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">email</span>&gt;</span>he_qiao_2010@yeah.net<span class="hljs-tag">&lt;/<span class="hljs-name">email</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">organization</span>&gt;</span>heqiao2010<span class="hljs-tag">&lt;/<span class="hljs-name">organization</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">developer</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">developers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.heqiao2010<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lunar<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>LunarCalendar<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>A Java implementation of Chinese lunar calendar. <span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.code.gson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>release<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>                    <span class="hljs-comment">&lt;!-- Source --&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-source-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                                    <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>jar-no-fork<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>                                <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                            <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-comment">&lt;!-- Javadoc --&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                                    <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>                                <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                            <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                    <span class="hljs-comment">&lt;!-- GPG --&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-gpg-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>verify<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>                                <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                                    <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>sign<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>                                <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                            <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">snapshotRepository</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>oss<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://oss.sonatype.org/content/repositories/snapshots/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">snapshotRepository</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>oss<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://oss.sonatype.org/service/local/staging/deploy/maven2/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><h2 id="生成并上传密钥"><a href="#生成并上传密钥" class="headerlink" title="生成并上传密钥"></a>生成并上传密钥</h2><p>运行如下命令，根据提示生成密钥，需要设置pharse。</p><pre><code class="hljs ada">gpg <span class="hljs-comment">--gen-key</span></code></pre><p>生成的密钥类似：</p><pre><code class="hljs angelscript">➜  ~ gpg --list-keys /home/qiaohe/.gnupg/pubring.gpg-------------------------------pub   rsa3072 <span class="hljs-number">2019</span><span class="hljs-number">-06</span><span class="hljs-number">-21</span> [SC] [有效至：<span class="hljs-number">2021</span><span class="hljs-number">-06</span><span class="hljs-number">-20</span>]      <span class="hljs-number">812</span>FAC0448CBA6C3E8EA8EA67BA82CF4A21310B2uid           [ 绝对 ] Joel Herb &lt;<span class="hljs-symbol">he_qiao_2010@</span>yeah.net&gt;sub   rsa3072 <span class="hljs-number">2019</span><span class="hljs-number">-06</span><span class="hljs-number">-21</span> [E] [有效至：<span class="hljs-number">2021</span><span class="hljs-number">-06</span><span class="hljs-number">-20</span>]</code></pre><p>然后上传密钥：</p><pre><code class="hljs apache"><span class="hljs-attribute">gpg</span> --keyserver hkp://keyserver.ubuntu.com:<span class="hljs-number">11371</span> --send-keys <span class="hljs-number">812</span>FAC<span class="hljs-number">0448</span>CBA<span class="hljs-number">6</span>C<span class="hljs-number">3</span>E<span class="hljs-number">8</span>EA<span class="hljs-number">8</span>EA<span class="hljs-number">67</span>BA<span class="hljs-number">82</span>CF<span class="hljs-number">4</span>A<span class="hljs-number">21310</span>B<span class="hljs-number">2</span></code></pre><h2 id="执行部署"><a href="#执行部署" class="headerlink" title="执行部署"></a>执行部署</h2><pre><code class="hljs arduino">mvn clean deploy -P <span class="hljs-built_in">release</span></code></pre><p>-P命令用于指定pom文件中profile的id。在编译之后，上传到中央服务器的时候，系统会提示让你输入密钥中的phrase，如果是windows系统可以在编译命令后加上<code>-Dgpg.passphrase=设置的pharse</code></p><p>上传完成之后在<a href="https://oss.sonatype.org/">https://oss.sonatype.org</a> （登陆账号和新建issue的账号一致）这个页面的staging repositories页签中可以看到刚才上传的内容，默认是open状态的，先点击上方的close然后再点击release即可。注意relesea版本的jar中的版本号不能带SNAPSHOT字样，因为SNAPSHOT版本是不稳定版，不应该release，否则会有歧义，容易引起误解。</p><h2 id="通知管理员"><a href="#通知管理员" class="headerlink" title="通知管理员"></a>通知管理员</h2><p>在之前创建的issue下，评论通知管理员，已经上传jar包了。等管理员操作之后，在中央仓库就可以看到上传的jar包了。例如：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.heqiao2010<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lunar<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/ljbmxsm/article/details/78009268">https://blog.csdn.net/ljbmxsm/article/details/78009268</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;之前在github上开发了一个简单的项目，一直想把这个jar包发布到中央仓库。一直没有时间弄这个，今天抽出点时间，按照网上的例子，操作了一遍，顺便记录一下，一遍将来参考。我的开发环境是ubuntu18.04，maven3，整个过程还是比较顺利的。&lt;</summary>
      
    
    
    
    <category term="git" scheme="http://heqiao2010.github.io/categories/git/"/>
    
    
    <category term="Maven" scheme="http://heqiao2010.github.io/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Freemarker中如何避免xss漏洞</title>
    <link href="http://heqiao2010.github.io/2019/06/20/Freemarker%E4%B8%AD%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8Dxss%E6%BC%8F%E6%B4%9E/"/>
    <id>http://heqiao2010.github.io/2019/06/20/Freemarker%E4%B8%AD%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8Dxss%E6%BC%8F%E6%B4%9E/</id>
    <published>2019-06-20T10:00:00.000Z</published>
    <updated>2021-08-14T12:30:43.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是XSS漏洞"><a href="#什么是XSS漏洞" class="headerlink" title="什么是XSS漏洞"></a>什么是XSS漏洞</h2><p>试想一下，如果我们开发一个订单系统，订单名称如果没有做限制，允许用户输入任意字符，那么就有产生XSS的危险。攻击者可以很容易编写一个恶意JS脚本,然后将当前登录用户的cookie或者其他敏感信息抓取到，发送给攻击者自己，这就是XSS（跨站脚本）攻击。如何解决这个问题，首先我们想到的是在用户输入订单的时候，我们对订单名称做限制，不允许输入特殊字符。这样是可以避免的，不过对于一个大的系统来说，用户可以输入的字段太多了，如果能够全部校验，是最好的。如果不能做的话，还可以让前端在做展示的时候进行html转义处理一下，这样原本scirpt标签以及当中的内容就被当做一个字符串展示出来，而不是当做代码执行了。一般现在的reactjs等前端框架已经默认支持防xss了。今天我遇到的问题是，有一部分freemarker写的页面存在XSS的问题。</p><h2 id="FreeMarker中解决XSS"><a href="#FreeMarker中解决XSS" class="headerlink" title="FreeMarker中解决XSS"></a>FreeMarker中解决XSS</h2><p>可以通过对用户输入的字段进行html转义，来有效的避免XSS问题。freemarker模板中的变量通过${value}这样的形式引入，但是挨个修改成<code>$&#123;value?html&#125;</code>的形式未免工作量太大；查阅官方文档，通过escape标签可以对整个模板中$号引入的变量全部进行一次html转义。比如：</p><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">#assign</span> <span class="hljs-attr">x</span> = <span class="hljs-string">&quot;&lt;test&gt;&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">#macro</span> <span class="hljs-attr">m1</span>&gt;</span></span><span class="xml">  m1: $</span><span class="hljs-template-variable">&#123;x&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">#macro</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">#escape</span> <span class="hljs-attr">x</span> <span class="hljs-attr">as</span> <span class="hljs-attr">x</span>?<span class="hljs-attr">html</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">#macro</span> <span class="hljs-attr">m2</span>&gt;</span>m2: $</span><span class="hljs-template-variable">&#123;x&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">#macro</span>&gt;</span></span><span class="xml">  $</span><span class="hljs-template-variable">&#123;x&#125;</span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">@m1</span>/&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">#escape</span>&gt;</span></span><span class="xml">$</span><span class="hljs-template-variable">&#123;x&#125;</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">@m2</span>/&gt;</span></span></code></pre><p>会输出：</p><pre><code class="hljs dts">  <span class="hljs-variable">&amp;lt</span>;test<span class="hljs-variable">&amp;gt</span>;<span class="hljs-symbol">  m1:</span> <span class="hljs-params">&lt;test&gt;</span><span class="hljs-params">&lt;test&gt;</span><span class="hljs-symbol">m2:</span> <span class="hljs-variable">&amp;lt</span>;test<span class="hljs-variable">&amp;gt</span>;</code></pre><p>这种方式完全满足现在的改造需求。在这个项目中，freemarker模板是存储在数据库中，所有用到freemarker渲染的地方均是用的同一个入口；这样工作量就不大了。我们知道，freemarker加载模板是通过TemplateLoader这个接口来实现的；只需要在加载模板的时候在模板的头部加上<code>&lt;#escape x as x?html&gt;</code>在尾部加上<code>&lt;/#escape</code>就可以对模板中所有的变量进行html转义了。通过这种方式数据库中的数据也不用修改，将来生成模板，也不需要考虑做html转义的问题。</p><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">TemplateLoader</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">findTemplateSource</span>(<span class="hljs-params">String name</span>)</span><span class="hljs-function">    throws IOException</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> <span class="hljs-title">getLastModified</span>(<span class="hljs-params">Object templateSource</span>)</span>;      <span class="hljs-function"><span class="hljs-keyword">public</span> Reader <span class="hljs-title">getReader</span>(<span class="hljs-params">Object templateSource, String encoding</span>) throws IOException</span>;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeTemplateSource</span>(<span class="hljs-params">Object templateSource</span>) throws IOException</span>;    &#125;</code></pre><p>由于实现逻辑还是从外部读取字符串加载，所以TemplateLoader接口支持html转义的实现和StringTemplateLoader的逻辑差不多。</p><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HtmlEscapeTemplateLoader</span> <span class="hljs-title">implements</span> <span class="hljs-title">TemplateLoader</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-built_in">String</span> HTML_ESCAPE_PREFIX = <span class="hljs-string">&quot;&lt;#escape x as x?html&gt;&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-built_in">String</span> HTML_ESCAPE_SUFFIX = <span class="hljs-string">&quot;&lt;/#escape&gt;&quot;</span>;    <span class="hljs-comment">// 为了支持并发，这里采用ConcurrentMap</span>    <span class="hljs-keyword">private</span> final <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, StringTemplateSource&gt; templates = Maps.newConcurrentMap();    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">putTemplate</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, <span class="hljs-built_in">String</span> templateContent</span>)</span> &#123;        putTemplate(name, templateContent, System.currentTimeMillis());    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">putTemplate</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, <span class="hljs-built_in">String</span> templateContent, long lastModified</span>)</span> &#123;        templates.put(name, <span class="hljs-keyword">new</span> HtmlEscapeTemplateLoader.StringTemplateSource(name, templateContent, lastModified));    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">removeTemplate</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;        <span class="hljs-keyword">return</span> templates.remove(name) != <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">closeTemplateSource</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> templateSource</span>)</span> &#123;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Object</span> <span class="hljs-function"><span class="hljs-title">findTemplateSource</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span> &#123;        <span class="hljs-keyword">return</span> templates.get(name);    &#125;    <span class="hljs-keyword">public</span> long <span class="hljs-function"><span class="hljs-title">getLastModified</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> templateSource</span>)</span> &#123;        <span class="hljs-keyword">return</span> ((HtmlEscapeTemplateLoader.StringTemplateSource) templateSource).lastModified;    &#125;    <span class="hljs-keyword">public</span> Reader getReader(<span class="hljs-built_in">Object</span> templateSource, <span class="hljs-built_in">String</span> encoding) throws IOException &#123;        Reader reader = <span class="hljs-keyword">new</span> StringReader(((StringTemplateSource) templateSource).templateContent);        <span class="hljs-built_in">String</span> templateText = IOUtils.toString(reader);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StringReader(HTML_ESCAPE_PREFIX + templateText + HTML_ESCAPE_SUFFIX);    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTemplateSource</span> </span>&#123;        <span class="hljs-keyword">private</span> final <span class="hljs-built_in">String</span> name;        <span class="hljs-keyword">private</span> final <span class="hljs-built_in">String</span> templateContent;        <span class="hljs-keyword">private</span> final long lastModified;        <span class="hljs-function"><span class="hljs-title">StringTemplateSource</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, <span class="hljs-built_in">String</span> templateContent, long lastModified</span>)</span> &#123;            <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;name == null&quot;</span>);            &#125;            <span class="hljs-keyword">if</span> (templateContent == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;source == null&quot;</span>);            &#125;            <span class="hljs-keyword">if</span> (lastModified &lt; -<span class="hljs-number">1</span>L) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;lastModified &lt; -1L&quot;</span>);            &#125;            <span class="hljs-built_in">this</span>.name = name;            <span class="hljs-built_in">this</span>.templateContent = templateContent;            <span class="hljs-built_in">this</span>.lastModified = lastModified;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">hashCode</span>(<span class="hljs-params"></span>)</span> &#123;            final int prime = <span class="hljs-number">31</span>;            int result = <span class="hljs-number">1</span>;            result = prime * result + ((name == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : name.hashCode());            <span class="hljs-keyword">return</span> result;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">equals</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> obj</span>)</span> &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == obj)                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>)                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            <span class="hljs-keyword">if</span> (getClass() != obj.getClass())                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            HtmlEscapeTemplateLoader.StringTemplateSource other = (HtmlEscapeTemplateLoader.StringTemplateSource) obj;            <span class="hljs-keyword">if</span> (name == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-keyword">if</span> (other.name != <span class="hljs-literal">null</span>)                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!name.equals(other.name))                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;            <span class="hljs-keyword">return</span> name;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Show class name and some details that are useful in template-not-found errors.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@since </span>2.3.21</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();        sb.append(getClassNameForToString(<span class="hljs-built_in">this</span>));        sb.append(<span class="hljs-string">&quot;(Map &#123; &quot;</span>);        int cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">String</span> name : templates.keySet()) &#123;            cnt++;            <span class="hljs-keyword">if</span> (cnt != <span class="hljs-number">1</span>) &#123;                sb.append(<span class="hljs-string">&quot;, &quot;</span>);            &#125;            <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">10</span>) &#123;                sb.append(<span class="hljs-string">&quot;...&quot;</span>);                <span class="hljs-keyword">break</span>;            &#125;            sb.append(StringUtil.jQuote(name));            sb.append(<span class="hljs-string">&quot;=...&quot;</span>);        &#125;        <span class="hljs-keyword">if</span> (cnt != <span class="hljs-number">0</span>) &#123;            sb.append(<span class="hljs-string">&#x27; &#x27;</span>);        &#125;        sb.append(<span class="hljs-string">&quot;&#125;)&quot;</span>);        <span class="hljs-keyword">return</span> sb.toString();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getClassNameForToString</span>(<span class="hljs-params">TemplateLoader templateLoader</span>)</span> &#123;        final Class tlClass = templateLoader.getClass();        final Package tlPackage = tlClass.getPackage();        <span class="hljs-keyword">return</span> tlPackage == Configuration.class.getPackage() || tlPackage == TemplateLoader.class.getPackage()                ? tlClass.getSimpleName() : tlClass.getName();    &#125;&#125;</code></pre><p>至此实现了在freemarker中自动进行html转义避免XSS问题的过程。参考网上有些资料可以修改freemarker的源码，对其在进行<code>$</code>号解析的时候，自动加上html转义的逻辑，也是可以的。如果某些特殊情况下，就是需要展示html形式的内容而不需要转义，或者有人错误的将变量进行了一次转义比如写成<code>$&#123;!(value)?html&#125;</code>的形式，会怎样？</p><p>如果就是需要展示html形式的内容而不需要转义，可以用<code>&lt;#noescape&gt;</code>标签将不需要转义的变量包裹起来，这样就算外层有<code>&lt;#escape&gt;</code>也不会进行转义了。如果在外部有<code>&lt;#escape&gt;</code>的情况下，变量自身又做了一次转义，那么该变量会被转义两次。正常字符不会有影响，含有特殊字符的话，可能比较难看了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/shadowsick/article/details/80768868">https://blog.csdn.net/shadowsick/article/details/80768868</a><br><a href="https://my.oschina.net/greki/blog/83246?p=1">https://my.oschina.net/greki/blog/83246?p=1</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是XSS漏洞&quot;&gt;&lt;a href=&quot;#什么是XSS漏洞&quot; class=&quot;headerlink&quot; title=&quot;什么是XSS漏洞&quot;&gt;&lt;/a&gt;什么是XSS漏洞&lt;/h2&gt;&lt;p&gt;试想一下，如果我们开发一个订单系统，订单名称如果没有做限制，允许用户输入任意字符，那么就有产</summary>
      
    
    
    
    <category term="security" scheme="http://heqiao2010.github.io/categories/security/"/>
    
    
    <category term="Freemarker" scheme="http://heqiao2010.github.io/tags/Freemarker/"/>
    
  </entry>
  
  <entry>
    <title>VirtualBox虚拟机和宿主机实现网络互通配置</title>
    <link href="http://heqiao2010.github.io/2019/06/19/VirtualBox%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A%E9%85%8D%E7%BD%AE/"/>
    <id>http://heqiao2010.github.io/2019/06/19/VirtualBox%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E4%BA%92%E9%80%9A%E9%85%8D%E7%BD%AE/</id>
    <published>2019-06-19T10:00:00.000Z</published>
    <updated>2021-08-14T12:30:41.541Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于想要在本地测试一下syslog以及安装jenkins等需求，所以想在本地安装一个虚拟机，并且能够在宿主机上访问，所以想利于virtualbox上安装一个linux来实现，尝试了几次，其实配置挺简单的，这里记录一下。</p></blockquote><h2 id="接入方式对比"><a href="#接入方式对比" class="headerlink" title="接入方式对比"></a>接入方式对比</h2><p>VirtualBox的提供了四种网络接入模式</p><ol><li>NAT 网络地址转换模式(NAT,Network Address Translation) ：<br>宿主机做nat转换，对外外部网络来说，虚拟机是不可见的，因为宿主机代理了虚拟机的所有请求。</li><li>Bridged Adapter 桥接模式 ：<br>对于虚拟机，外部网络可见，虚拟机和宿主机存在于同一个网段。</li><li>Internal 内部网络模式 ：创建一个隔离的虚拟网络，在这个网络中的虚拟机之间可以相互访问，虚拟机不能访问外部网络，外部网络也不能访问内部虚拟机。</li><li>Host-only Adapter 主机模式 ：　也可以通过配置实现，下次有机会再看看。</li></ol><p>各个接入方式对比：</p><table><thead><tr><th></th><th align="center">NAT</th><th>Bridged</th><th>Internal</th><th align="right">Host-only</th></tr></thead><tbody><tr><td>虚拟机－&gt;宿主机</td><td align="center">√</td><td>√</td><td>×</td><td align="right">默认不能，需设置</td></tr><tr><td>宿主机－&gt;虚拟机</td><td align="center">×</td><td>√</td><td>×</td><td align="right">默认不能，需设置</td></tr><tr><td>虚拟机－&gt;其他主机</td><td align="center">√</td><td>√</td><td>×</td><td align="right">默认不能，需设置</td></tr><tr><td>其他主机－&gt;宿主机</td><td align="center">×</td><td>√</td><td>×</td><td align="right">默认不能，需设置</td></tr><tr><td>虚拟机之间</td><td align="center">×</td><td>√</td><td>同网络名下可以</td><td align="right">√</td></tr></tbody></table><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>从对比中可以看出桥接方式是最优的方案，但是配置之后，宿主机和虚拟机之间能够互通，但是在虚拟机中不能上外网了，因为配置的宿主机DNS不能解析外部域名，而虚拟机中也无法ping通诸如114.114.114.114的地址。</p><p>如果做NAT的话，虚拟机是可以访问外网的，所以可以给虚拟机设置两个网卡。一个做桥接一个做NAT就达到目的了。</p><p><img src="/images/23.png"></p><p>需要注意的是桥接网卡在虚拟机中需要手动配置一个和宿主机同网段的IP，网关和DNS最好和宿主机配置一致。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/chaishen10000/article/details/82984811">https://blog.csdn.net/chaishen10000/article/details/82984811</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;由于想要在本地测试一下syslog以及安装jenkins等需求，所以想在本地安装一个虚拟机，并且能够在宿主机上访问，所以想利于virtualbox上安装一个linux来实现，尝试了几次，其实配置挺简单的，这里记录一下。&lt;/p&gt;
&lt;/blockquo</summary>
      
    
    
    
    <category term="虚拟机" scheme="http://heqiao2010.github.io/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="VirtualBox" scheme="http://heqiao2010.github.io/tags/VirtualBox/"/>
    
  </entry>
  
  <entry>
    <title>记一次重写RequestMappingHandlerMapping的经历</title>
    <link href="http://heqiao2010.github.io/2019/06/17/%E4%B8%80%E6%AC%A1%E9%87%8D%E5%86%99RequestMappingHandlerMapping%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <id>http://heqiao2010.github.io/2019/06/17/%E4%B8%80%E6%AC%A1%E9%87%8D%E5%86%99RequestMappingHandlerMapping%E7%9A%84%E7%BB%8F%E5%8E%86/</id>
    <published>2019-06-17T10:00:00.000Z</published>
    <updated>2021-08-14T12:30:43.081Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>近期公司的产品做了一次安全审查，发现后端提供的接口有<strong>不安全的Http方法</strong>漏洞。不安全的HTTP方法一般包括：TRACE、PUT、DELETE、COPY 等。其中最常见的为TRACE方法可以回显服务器收到的请求，主要用于测试或诊断，恶意攻击者可以利用该方法进行跨站跟踪攻击（即XST攻击），从而进行网站钓鱼、盗取管理员cookie等。</p></blockquote><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>引起这个问题的原因其实很简单，因为开发人员开发接口的时候偷懒没有指定RequestMapping中的method属性导致的。没有指定method则系统会默认支持除了TRACE之外的其他７中方式，所以，这就是我要重写的RequestMappingHandlerMapping原因。</p><p>当然还有其他的方式，比如搜索出所有采用RequestMapping而没有指定method的地方，然后在代码中明确指定method。这种方式思路最简单，但是毕竟人是懒惰的。而且将来代码开发中如果任然有人不指定method，那么这个问题任然会存在。所以我们需要改动一下，框架加载http接口映射关系的逻辑：</p><p>在没有指定method的情况下，只支持GET和POST；在明确指定method的情况下，保留指定的method。</p><h2 id="为什么重写的是RequestMappingHandlerMapping"><a href="#为什么重写的是RequestMappingHandlerMapping" class="headerlink" title="为什么重写的是RequestMappingHandlerMapping"></a>为什么重写的是RequestMappingHandlerMapping</h2><p>首先后端提供的Http请求均是通过RestController和RequestMapping(或者衍生的GetMapping/PostMapping等)来实现的。那在接收http请求之后，如何将http请求映射到具体的Controller中的方法上呢？答案在HandlerMapping这个接口。这个具体映射过程细节以后再说，而HandlerMapping接口的映射方法getHandler是在AbstractHandlerMapping中实现的，而AbstractHandlerMapping的一个非抽象子类就是RequestMappingHandlerMapping。</p><h2 id="重写RequestMappingHandlerMapping的哪个方法"><a href="#重写RequestMappingHandlerMapping的哪个方法" class="headerlink" title="重写RequestMappingHandlerMapping的哪个方法"></a>重写RequestMappingHandlerMapping的哪个方法</h2><p>从RequestMappingHandlerMapping中的getMappingForMethod方法可以看出，接口的映射信息，是由两部分组成的。一部分是来自于Controller类上的RequestMapping注解，一部分是来自于方法上的RequestMapping注解。所以，在这个方法中createRequestMappingInfo调用了两次，然后再组合。</p><pre><code class="hljs oxygene">@<span class="hljs-keyword">Override</span><span class="hljs-keyword">protected</span> RequestMappingInfo getMappingForMethod(<span class="hljs-function"><span class="hljs-keyword">Method</span> <span class="hljs-title">method</span>, <span class="hljs-title">Class</span>&lt;?&gt; <span class="hljs-title">handlerType</span>) <span class="hljs-comment">&#123;</span></span><span class="hljs-function"><span class="hljs-comment">RequestMappingInfo info = createRequestMappingInfo(method);</span></span><span class="hljs-function"><span class="hljs-comment">if (info != null) &#123;</span></span><span class="hljs-function"><span class="hljs-comment">RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);</span></span><span class="hljs-function"><span class="hljs-comment">if (typeInfo != null) &#123;</span></span><span class="hljs-function"><span class="hljs-comment">info = typeInfo.combine(info);</span></span><span class="hljs-function"><span class="hljs-comment">&#125;</span></span><span class="hljs-function">&#125;</span><span class="hljs-function"><span class="hljs-title">return</span> <span class="hljs-title">info</span>;</span>&#125;</code></pre><p>真正的createRequestMappingInfo有一个代理方法。</p><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> RequestMappingInfo create<span class="hljs-constructor">RequestMappingInfo(AnnotatedElement <span class="hljs-params">element</span>)</span> &#123;RequestMapping requestMapping = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AnnotatedElementUtils</span>.</span></span>find<span class="hljs-constructor">MergedAnnotation(<span class="hljs-params">element</span>, RequestMapping.<span class="hljs-params">class</span>)</span>;RequestCondition&lt;?&gt; condition = (element instanceof Class ?get<span class="hljs-constructor">CustomTypeCondition((Class&lt;?&gt;)</span> element) : get<span class="hljs-constructor">CustomMethodCondition((Method)</span> element));return (requestMapping != null ? create<span class="hljs-constructor">RequestMappingInfo(<span class="hljs-params">requestMapping</span>, <span class="hljs-params">condition</span>)</span> : null);&#125;</code></pre><p>在createRequestMappingInfo中，找到我们想要改动的地方了。在RequestMappingInfo设置method的时候增加一段自己的逻辑即可。</p><pre><code class="hljs less"><span class="hljs-selector-tag">protected</span> <span class="hljs-selector-tag">RequestMappingInfo</span> <span class="hljs-selector-tag">createRequestMappingInfo</span>(RequestMapping requestMapping, RequestCondition&lt;?&gt; customCondition) &#123;<span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">RequestMappingInfo</span><span class="hljs-selector-class">.paths</span>(resolveEmbeddedValuesInPatterns(requestMapping.path()))<span class="hljs-selector-class">.methods</span>(requestMapping.method())<span class="hljs-selector-class">.params</span>(requestMapping.params())<span class="hljs-selector-class">.headers</span>(requestMapping.headers())<span class="hljs-selector-class">.consumes</span>(requestMapping.consumes())<span class="hljs-selector-class">.produces</span>(requestMapping.produces())<span class="hljs-selector-class">.mappingName</span>(requestMapping.name())<span class="hljs-selector-class">.customCondition</span>(customCondition)<span class="hljs-selector-class">.options</span>(this.config)<span class="hljs-selector-class">.build</span>();&#125;</code></pre><p>至此,可以重写RequestMappingHandlerMapping如下：</p><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpSafetyRequestMappingHandlerMapping</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RequestMappingHandlerMapping</span></span>&#123;    <span class="hljs-keyword">private</span> RequestMappingInfo.BuilderConfiguration config = <span class="hljs-keyword">new</span> RequestMappingInfo.BuilderConfiguration();    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> RequestMappingInfo createRequestMappingInfo(RequestMapping requestMapping,                                                          RequestCondition&lt;?&gt; customCondition) &#123;        <span class="hljs-comment">// 如果Controller的方法上RequestMapping没有指定Method，则只支持GET和POST</span>        RequestMethod[] methods = &#123; RequestMethod.GET, RequestMethod.POST &#125;;        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">requestMapping.method().length != <span class="hljs-number">0</span></span>)</span>&#123;            methods = requestMapping.method();        &#125;        <span class="hljs-keyword">return</span> RequestMappingInfo                .paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))                .methods(methods)                .params(requestMapping.params())                .headers(requestMapping.headers())                .consumes(requestMapping.consumes())                .produces(requestMapping.produces())                .mappingName(requestMapping.name())                .customCondition(customCondition)                .options(config)                .build();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> RequestMappingInfo <span class="hljs-function"><span class="hljs-title">getMappingForMethod</span>(<span class="hljs-params">Method method, Class&lt;?&gt; handlerType</span>)</span> &#123;        RequestMappingInfo info = createRequestMappingInfo(method);        <span class="hljs-keyword">if</span> (info != <span class="hljs-literal">null</span>) &#123;            RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);            <span class="hljs-keyword">if</span> (typeInfo != <span class="hljs-literal">null</span>) &#123;                info = typeInfo.combine(info);            &#125;        &#125;        <span class="hljs-keyword">return</span> info;    &#125;    <span class="hljs-keyword">private</span> RequestMappingInfo <span class="hljs-function"><span class="hljs-title">createRequestMappingInfo</span>(<span class="hljs-params">AnnotatedElement element</span>)</span> &#123;        RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class);        RequestCondition&lt;?&gt; condition = (element <span class="hljs-keyword">instanceof</span> Class ?                getCustomTypeCondition((Class&lt;?&gt;) element) : getCustomMethodCondition((Method) element));        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">requestMapping == <span class="hljs-literal">null</span></span>)</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-comment">// 只需要处理方法上的RequestMapping，Controller类上的不需要处理</span>        <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">element <span class="hljs-keyword">instanceof</span> Class</span>)</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.createRequestMappingInfo(requestMapping, condition);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> createRequestMappingInfo(requestMapping, condition);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">afterPropertiesSet</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-built_in">this</span>.config = <span class="hljs-keyword">new</span> RequestMappingInfo.BuilderConfiguration();        <span class="hljs-built_in">this</span>.config.setUrlPathHelper(getUrlPathHelper());        <span class="hljs-built_in">this</span>.config.setPathMatcher(getPathMatcher());        <span class="hljs-built_in">this</span>.config.setSuffixPatternMatch(useSuffixPatternMatch());        <span class="hljs-built_in">this</span>.config.setTrailingSlashMatch(useTrailingSlashMatch());        <span class="hljs-built_in">this</span>.config.setRegisteredSuffixPatternMatch(useRegisteredSuffixPatternMatch());        <span class="hljs-built_in">this</span>.config.setContentNegotiationManager(getContentNegotiationManager());        <span class="hljs-built_in">super</span>.afterPropertiesSet();    &#125;&#125;</code></pre><h2 id="如何替换"><a href="#如何替换" class="headerlink" title="如何替换"></a>如何替换</h2><p>网关服务采用Spring boot开发，那么我们可以从<code>org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration</code>入手。此类中有一个内部类：EnableWebMvcConfiguration，它继承并重写了createRequestMappingHandlerMapping方法。我们知道，在WebMvcConfigurationSupport类中，RequestMappingHandlerMapping实例的获取是通过其：requestMappingHandlerMapping方法上增加Bean注解来实现的。</p><p>这几个类的关系：</p><pre><code class="hljs gherkin">WebMvcConfigurationSupport^|<span class="hljs-string"> 继承</span><span class="hljs-string">DelegatingWebMvcConfiguration</span><span class="hljs-string">^</span>|<span class="hljs-string"> 继承</span><span class="hljs-string">EnableWebMvcConfiguration</span><span class="hljs-string">^      ^ </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> @Import</span>|<span class="hljs-string">　WebMvcAutoConfigurationAdapter</span>|<span class="hljs-string">　　　　　　　 ^ 静态内部类</span>|<span class="hljs-string">             </span>||<span class="hljs-string"> 静态内部类　　</span>|WebMvcAutoConfiguration</code></pre><p>在WebMvcConfigurationSupport的requestMappingHandlerMapping方法中，RequestMappingHanlderMapping是通过调用createRequestMappingHandlerMapping方法来实现的。所以要覆盖RequestMappingHanlderMapping的实现，只需要重写createRequestMappingHandlerMapping即可。而EnableWebMvcConfiguration已经将这个方法重写如下：</p><pre><code class="hljs kotlin">      <span class="hljs-meta">@Override</span><span class="hljs-keyword">protected</span> RequestMappingHandlerMapping createRequestMappingHandlerMapping() &#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.mvcRegistrations != <span class="hljs-literal">null</span>&amp;&amp; <span class="hljs-keyword">this</span>.mvcRegistrations.getRequestMappingHandlerMapping() != <span class="hljs-literal">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.mvcRegistrations.getRequestMappingHandlerMapping();&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.createRequestMappingHandlerMapping();&#125;</code></pre><p>从上面的代码可以看出，EnableWebMvcConfiguration已经提供了替换RequestMappingHandlerMapping的方式，那就是：WebMvcRegistrations。而WebMvcRegistrations是个接口，并有一个默认的空实现：WebMvcRegistrationsAdapter，只需要覆盖其中的getRequestMappingHandlerMapping方法即可。</p><pre><code class="hljs scala"><span class="hljs-meta">@Component</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SafetyWebMvcRegistrationsAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcRegistrationsAdapter</span></span>&#123;    <span class="hljs-meta">@Override</span>    public <span class="hljs-type">RequestMappingHandlerMapping</span> getRequestMappingHandlerMapping() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">HttpSafetyRequestMappingHandlerMapping</span>();    &#125;&#125;</code></pre><p>至此Sping boot中替换RequestMappingHandlerMapping的实现就结束了。</p><p>不过我们另一个服务采用的是Spring mvc,上面的替换就不生效了。因为服务中WebApplicationContext是通过@EnableWebMvc注入的配置。而在这个注解中导入的实际上是DelegatingWebMvcConfiguration。</p><pre><code class="hljs less"><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-variable">@Target</span>(ElementType.TYPE)<span class="hljs-variable">@Documented</span><span class="hljs-variable">@Import</span>(DelegatingWebMvcConfiguration.class)public <span class="hljs-variable">@interface</span> EnableWebMvc &#123;&#125;</code></pre><p>所以把@EnableWebMvc替换成@Import(WebMvcAutoConfiguration.EnableWebMvcConfiguration.class)即可。或者重写DelegatingWebMvcConfiguration，覆盖createRequestMappingHandlerMapping方法也是可以的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;近期公司的产品做了一次安全审查，发现后端提供的接口有&lt;strong&gt;不安全的Http方法&lt;/strong&gt;漏洞。不安全的HTTP方法一般包括：TRACE、PUT、DELETE、COPY 等。其中最常见的为TRACE方法可以回显服务器收到的请求，主要</summary>
      
    
    
    
    <category term="security" scheme="http://heqiao2010.github.io/categories/security/"/>
    
    
    <category term="Spring" scheme="http://heqiao2010.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>如何获取用户真实IP</title>
    <link href="http://heqiao2010.github.io/2019/06/14/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E7%9C%9F%E5%AE%9EIP/"/>
    <id>http://heqiao2010.github.io/2019/06/14/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E7%9C%9F%E5%AE%9EIP/</id>
    <published>2019-06-14T10:00:00.000Z</published>
    <updated>2021-08-14T12:30:41.461Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在web开发过程中，我们经常需要获取用户客户端的真实IP。比如我们想知道客户的地理位置分布；比如服务端需要将会话和IP地址绑定，以提高安全性等。但是一般在分布式系统中，为了提高系统的可靠性和性能，都会采用代理来分发用户的请求，导致获取用户真实IP变得有些麻烦。</p></blockquote><h2 id="获取调用方IP的方法"><a href="#获取调用方IP的方法" class="headerlink" title="获取调用方IP的方法"></a>获取调用方IP的方法</h2><p>直接调用HttpServletRequest中的request.getRemoteAddr()方法，获取的IP地址，是当前服务的上游服务的IP地址，在没有代理的情况下是准确的，不过一般都会有一个或者多个代理，这种方式一般不适用。一般可能用如下几个字段</p><h3 id="X-FORWARDED-FOR"><a href="#X-FORWARDED-FOR" class="headerlink" title="X-FORWARDED-FOR"></a>X-FORWARDED-FOR</h3><p>X-FORWARDED-FOR这个http头是个调试参数，在代理服务器上做相关的配置，能够实现，在经过每一个代理的时候，会往后追加上代理的IP地址；这样通过这个字段就可以知道，这个请求被代理了多少次，每次代理是由那个IP处理的；所以取列表第一个IP就是用户的真实IP地址了。</p><p>nginx支持X-FORWARDED-FOR的配置：</p><pre><code class="hljs nginx"><span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;</code></pre><h3 id="Proxy-Client-IP"><a href="#Proxy-Client-IP" class="headerlink" title="Proxy-Client-IP"></a>Proxy-Client-IP</h3><p>用apache http做代理时一般会加上Proxy-Client-IP请求头</p><h3 id="WL-Proxy-Client-IP"><a href="#WL-Proxy-Client-IP" class="headerlink" title="WL-Proxy-Client-IP"></a>WL-Proxy-Client-IP</h3><p>weblogic插件加上的头</p><h3 id="HTTP-CLIENT-IP"><a href="#HTTP-CLIENT-IP" class="headerlink" title="HTTP_CLIENT_IP"></a>HTTP_CLIENT_IP</h3><p>有些代理服务器会加上此请求头。</p><h3 id="X-Real-IP"><a href="#X-Real-IP" class="headerlink" title="X-Real-IP"></a>X-Real-IP</h3><p>在nginx中可以把上游调用的真实IP加到HTTP请求头中，这个IP从remote_addr变量中获取是从TCP链接中获取的真实IP。</p><pre><code class="hljs nginx"><span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;</code></pre><h2 id="某些特殊情况"><a href="#某些特殊情况" class="headerlink" title="某些特殊情况"></a>某些特殊情况</h2><p>正常我们会按照上面的顺序按照优先级获取真实的IP地址。网上一般都会把X-FORWARDED-FOR这个参数作为第一优先级来处理。但是这个参数实际上是不安全的。<br>X-FORWARDED-FOR这个参数的值是个列表，每次经过代理都是往后追加，而不是覆盖的。所以不能确保IP是可信的。客户端可以先伪造一个IP放到头部，真实IP就会在伪造IP之后了。比如：</p><p>客户端伪造</p><pre><code class="hljs angelscript">X-FORWARDED-FOR：　<span class="hljs-number">1.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span></code></pre><p>经过两次代理（192.168.1.2,192.168.1.3）之后：</p><pre><code class="hljs angelscript">X-FORWARDED-FOR：　<span class="hljs-number">1.1</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span>,<span class="hljs-number">108.10</span><span class="hljs-number">.10</span><span class="hljs-number">.123</span>,<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span>,<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.3</span></code></pre><p>这样获取到的IP地址是1.1.1.1，而不是真正的108.10.10.123。其实真实IP已经在列表中了，怎么避免获取伪造的IP？</p><p>nginx有个realip模块，可以通过set_real_ip_from命令制定代理服务器的IP,因为代理服务器的IP地址都是已知的，所以可以通过从右至左依次获取第一个不在代理IP列表中的合法IP就是用户真实IP地址了。</p><pre><code class="hljs nginx"><span class="hljs-attribute">set_real_ip_from</span>  <span class="hljs-number">192.168.1.2</span>;<span class="hljs-attribute">set_real_ip_from</span>  <span class="hljs-number">192.168.1.3</span>;<span class="hljs-attribute">real_ip_header</span>    X-Forwarded-For;<span class="hljs-attribute">real_ip_recursive</span> <span class="hljs-literal">on</span>;</code></pre><p>安装realip模块需要重新编译nginx，比较麻烦，也可以直接通过最上层代理（第一层代理）服务器获取用户真实IP，写入http头部，后端服务优先获取此参数即可。比如：第一层代理是nginx,将remote_addr参数写入X-Real-IP，后端优先获取此参数，其他代理不要覆盖此参数即可；由于参数是覆盖写入的，就算客户端伪造一个X-Real-IP参数头，也会被代理服务器复写为真实的IP.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/1e0124de8e02">https://www.jianshu.com/p/1e0124de8e02</a><br><a href="http://nginx.org/en/docs/http/ngx_http_realip_module.html">http://nginx.org/en/docs/http/ngx_http_realip_module.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在web开发过程中，我们经常需要获取用户客户端的真实IP。比如我们想知道客户的地理位置分布；比如服务端需要将会话和IP地址绑定，以提高安全性等。但是一般在分布式系统中，为了提高系统的可靠性和性能，都会采用代理来分发用户的请求，导致获取用户真实IP变</summary>
      
    
    
    
    <category term="服务端" scheme="http://heqiao2010.github.io/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
    
    <category term="服务端" scheme="http://heqiao2010.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>git技巧之git stash</title>
    <link href="http://heqiao2010.github.io/2019/06/13/git%E6%8A%80%E5%B7%A7%E4%B9%8Bgitstash/"/>
    <id>http://heqiao2010.github.io/2019/06/13/git%E6%8A%80%E5%B7%A7%E4%B9%8Bgitstash/</id>
    <published>2019-06-13T10:00:00.000Z</published>
    <updated>2021-08-14T12:30:43.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>英文单词：stash的原意是储藏的意思。当我们在开发过程中，代码写了一部分，由于某种原因需要切换到另一个分支上，比如临时需要切换到另一个需求上开发另一个任务，这个时候就我们就需要某种手段临时保存手头上没有完成的任务，在另一个任务做完了之后，再恢复这个没有完成的任务继续开发。这个过程是不是有点类似，操作系统中发生函数调用时，保存现场和恢复现场？</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol><li><p>创建存储</p><pre><code class="hljs ebnf"><span class="hljs-attribute">git stash</span></code></pre><p>运行这个命令之后，会将当前所有的修改存储起来，再次运行git statu,会发现目录恢复成clean的状态了。这个时候就可以切换到其他分支了。</p></li><li><p>查看存储列表</p><pre><code class="hljs applescript">git stash <span class="hljs-built_in">list</span></code></pre><p>有时候，我们运行了stash多次，通过上面的命令，可以查看每次存储的记录；类似：</p><pre><code class="hljs applescript">$ git stash <span class="hljs-built_in">list</span>stash@&#123;<span class="hljs-number">0</span>&#125;: WIP <span class="hljs-keyword">on</span> master: <span class="hljs-number">049</span>d078 added <span class="hljs-keyword">the</span> index <span class="hljs-built_in">file</span>stash@&#123;<span class="hljs-number">1</span>&#125;: WIP <span class="hljs-keyword">on</span> master: c264051 Revert <span class="hljs-string">&quot;added file_size&quot;</span>stash@&#123;<span class="hljs-number">2</span>&#125;: WIP <span class="hljs-keyword">on</span> master: <span class="hljs-number">21</span>d80a5 added <span class="hljs-built_in">number</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">log</span></code></pre></li><li><p>恢复存储</p></li></ol><pre><code class="hljs gauss">git stash apply <span class="hljs-meta">#应用存储</span>git stash <span class="hljs-keyword">pop</span>　 <span class="hljs-meta">#应用并删除存储</span>git stash <span class="hljs-built_in">drop</span>　＃删除存储</code></pre><p>上面的命令默认对最近一次的存储进行操作，如果需要制定那个存储，可以在明后跟上存储的名称，例如：</p><pre><code class="hljs angelscript">git stash apply <span class="hljs-symbol">stash@</span>&#123;<span class="hljs-number">2</span>&#125;</code></pre><h3 id="从储藏中创建分支"><a href="#从储藏中创建分支" class="headerlink" title="从储藏中创建分支"></a>从储藏中创建分支</h3><pre><code class="hljs apache"><span class="hljs-attribute">git</span> stash branch<span class="hljs-meta"> [分支名]</span></code></pre><p>有时候想要对于暂存的代码新创建一个分支，可以用上面的命令进行；一般这种情况可能是应用存储时发生冲突，或者是想要创建分支进行其他操作。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%EF%BC%88Stashing%EF%BC%89">https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%EF%BC%88Stashing%EF%BC%89</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功能&lt;/h2&gt;&lt;p&gt;英文单词：stash的原意是储藏的意思。当我们在开发过程中，代码写了一部分，由于某种原因需要切换到另一个分支上，比如临时需要切换到另一个需求</summary>
      
    
    
    
    <category term="git" scheme="http://heqiao2010.github.io/categories/git/"/>
    
    
    <category term="git" scheme="http://heqiao2010.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Rsyslog限速问题</title>
    <link href="http://heqiao2010.github.io/2019/06/11/Rsyslog%E9%99%90%E9%80%9F%E9%97%AE%E9%A2%98/"/>
    <id>http://heqiao2010.github.io/2019/06/11/Rsyslog%E9%99%90%E9%80%9F%E9%97%AE%E9%A2%98/</id>
    <published>2019-06-11T04:28:52.000Z</published>
    <updated>2021-08-14T12:30:42.417Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题：</strong><br>今天遇到一个syslog间歇性缺失的问题，排查了一圈发现是限速导致的。</p><pre><code class="hljs excel">cat /<span class="hljs-built_in">var</span>/<span class="hljs-built_in">log</span>/message | grep <span class="hljs-built_in">rate</span>-limit</code></pre><p>有如下信息：</p><pre><code class="hljs angelscript">Feb  <span class="hljs-number">9</span> <span class="hljs-number">10</span>:<span class="hljs-number">22</span>:<span class="hljs-number">32</span> localhost rsyslogd: imuxsock lost <span class="hljs-number">432</span> messages <span class="hljs-keyword">from</span> pid <span class="hljs-number">9832</span> due to rate-limiting</code></pre><p><strong>解决：</strong></p><p>1.修改配置文件<br>对于centos6，修改/etc/rsyslog.conf新增</p><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$SystemLogRateLimitInterval</span> 0</span><span class="hljs-meta"><span class="hljs-meta-keyword">$SystemLogRateLimitBurst</span> 0</span><span class="hljs-meta"><span class="hljs-meta-keyword">$IMUxSockRateLimitBurst</span> 0</span><span class="hljs-meta"><span class="hljs-meta-keyword">$IMUXSockRateLimitInterval</span> 0</span><span class="hljs-meta"><span class="hljs-meta-keyword">$IMUxSockRateLimitSeverity</span> 7 </span></code></pre><p>对于centos7，修改/etc/rsyslog.conf新增</p><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$SystemLogRateLimitInterval</span> 0</span><span class="hljs-meta"><span class="hljs-meta-keyword">$SystemLogRateLimitBurst</span>    0</span># 在<span class="hljs-symbol">$</span>ModLoad imjournal之后新增<span class="hljs-meta"><span class="hljs-meta-keyword">$ImjournalRateLimitInterval</span> 0</span></code></pre><p>修改：/etc/systemd/journald.conf<br>注释掉：</p><pre><code class="hljs ini"><span class="hljs-attr">RateLimitInterval</span>=<span class="hljs-number">5</span>s<span class="hljs-attr">RateLimitBurst</span>=<span class="hljs-number">30000</span></code></pre><p>2.重启服务</p><pre><code class="hljs maxima">systemctl <span class="hljs-built_in">restart</span> systemd-journaldsystemctl <span class="hljs-built_in">restart</span> rsyslog</code></pre><p><strong>参考资料</strong><br><a href="https://www.thegeekdiary.com/imuxsock-lost-messages-from-pid-due-to-rate-limiting-rsyslog-rate-limiting-in-linux/">https://www.thegeekdiary.com/imuxsock-lost-messages-from-pid-due-to-rate-limiting-rsyslog-rate-limiting-in-linux/</a><br><a href="https://www.rsyslog.com/how-to-use-rate-limiting-in-rsyslog/">https://www.rsyslog.com/how-to-use-rate-limiting-in-rsyslog/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;br&gt;今天遇到一个syslog间歇性缺失的问题，排查了一圈发现是限速导致的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs excel&quot;&gt;cat /&lt;span class=&quot;hljs-built_in&quot;&gt;var&lt;/span&gt;</summary>
      
    
    
    
    <category term="syslog" scheme="http://heqiao2010.github.io/categories/syslog/"/>
    
    
    <category term="限速" scheme="http://heqiao2010.github.io/tags/%E9%99%90%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>Syslog基础</title>
    <link href="http://heqiao2010.github.io/2019/06/10/Syslog%E5%9F%BA%E7%A1%80/"/>
    <id>http://heqiao2010.github.io/2019/06/10/Syslog%E5%9F%BA%E7%A1%80/</id>
    <published>2019-06-10T10:00:00.000Z</published>
    <updated>2021-08-14T12:30:43.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Syslog基础"><a href="#Syslog基础" class="headerlink" title="Syslog基础"></a>Syslog基础</h1><p>Syslog是类Unix操作系统中，用于记录系统日志（产生自本地或者远程操作系统）到本地磁盘的一套日志格式以及对应的程序。完整的syslog日志中包含产生日志的程序模块（Facility）、严重性（Severity或 Level）、时间、主机名或IP、进程名、进程ID和正文。</p><h1 id="Syslog日志格式"><a href="#Syslog日志格式" class="headerlink" title="Syslog日志格式"></a>Syslog日志格式</h1><p>Syslog日志格式比较松散，一般分为PRI，HEADER以及MSG三个部分，例如：</p><pre><code class="hljs text">&lt;30&gt;Oct 9 22:33:20 hlfedora auditd[1787]: The audit daemon is exiting.</code></pre><h2 id="PRI部分"><a href="#PRI部分" class="headerlink" title="PRI部分"></a>PRI部分</h2><p>PRI部分由尖括号包含的一个数字构成，这个数字包含了程序模块（Facility）、严重性（Severity），这个数字是由Facility乘以 8，然后加上Severity得来。也就是说这个数字如果换成2进制的话，低位的3个bit表示Severity，剩下的高位的部分右移3位，就是表示Facility的值。Facility的定义如下：</p><p>|Numerical Code |         Facility|<br>-|-|-<br>|           0   |         kernel messages|<br>|           1   |         user-level messages|<br>|           2   |         mail system|<br>|           3   |         system daemons|<br>|           4   |         security/authorization messages (note 1)|<br>|           5   |         messages generated internally by syslogd|<br>|           6   |         line printer subsystem|<br>|           7   |         network news subsystem|<br>|           8   |         UUCP subsystem|<br>|           9   |         clock daemon (note 2)|<br>|          10   |         security/authorization messages (note 1)|<br>|          11   |         FTP daemon|<br>|          12   |         NTP subsystem|<br>|          13   |         log audit (note 1)|<br>|          14   |         log alert (note 1)|<br>|          15   |         clock daemon (note 2)|<br>|          16   |         local use 0  (local0)|<br>|          17   |         local use 1  (local1)|<br>|          18   |         local use 2  (local2)|<br>|          19   |         local use 3  (local3)|<br>|          20   |         local use 4  (local4)|<br>|          21   |         local use 5  (local5)|<br>|          22   |         local use 6  (local6)|<br>|          23   |         local use 7  (local7)|</p><p>Severity的定义：</p><p>|Numerical  Code |      Severity|<br>-|-|-<br>|           0    |   Emergency: system is unusable|<br>|           1    |   Alert: action must be taken immediately|<br>|           2    |   Critical: critical conditions|<br>|           3    |   Error: error conditions|<br>|           4    |   Warning: warning conditions|<br>|           5    |   Notice: normal but significant condition|<br>|           6    |   Informational: informational messages|<br>|           7    |   Debug: debug-level messages|</p><h2 id="HEADER部分"><a href="#HEADER部分" class="headerlink" title="HEADER部分"></a>HEADER部分</h2><p>HEADER部分包括两个字段，时间和主机名（或IP）。<br>时间紧跟在PRI后面，中间没有空格，格式必须是“Mmm dd hh:mm:ss”，不包括年份。“日”的数字如果是1～9，前面会补一个空格（也就是月份后面有两个空格），而“小时”、“分”、“秒”则在前面补“0”。月份取值包括：Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec；时间后边跟一个空格，然后是主机名或者IP地址，主机名不得包括域名部分。</p><h2 id="MSG部分"><a href="#MSG部分" class="headerlink" title="MSG部分"></a>MSG部分</h2><p>MSG部分又分为两个部分，TAG和Content。其中TAG部分是可选的。在前面的例子中（“&lt;30&gt;Oct 9 22:33:20 hlfedora auditd[1787]: The audit daemon is exiting.”），“auditd[1787]”是TAG部分，包含了进程名称和进程PID。PID可以没有，这个时候中括号也是没有的。进程PID有时甚至不是一个数字，例如“root-1787”，解析程序要做好容错准备。TAG后面用一个冒号隔开Content部分，这部分的内容是应用程序自定义的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/skyofbitbit/p/3674664.html">https://www.cnblogs.com/skyofbitbit/p/3674664.html</a></p><p><a href="http://www.ietf.org/rfc/rfc3164.txt">http://www.ietf.org/rfc/rfc3164.txt</a></p><p><a href="http://www.ietf.org/rfc/rfc3195.txt">http://www.ietf.org/rfc/rfc3195.txt</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Syslog基础&quot;&gt;&lt;a href=&quot;#Syslog基础&quot; class=&quot;headerlink&quot; title=&quot;Syslog基础&quot;&gt;&lt;/a&gt;Syslog基础&lt;/h1&gt;&lt;p&gt;Syslog是类Unix操作系统中，用于记录系统日志（产生自本地或者远程操作系统）到本地磁盘</summary>
      
    
    
    
    <category term="syslog" scheme="http://heqiao2010.github.io/categories/syslog/"/>
    
    
    <category term="linux" scheme="http://heqiao2010.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Swagger</title>
    <link href="http://heqiao2010.github.io/2019/06/06/Swagger/"/>
    <id>http://heqiao2010.github.io/2019/06/06/Swagger/</id>
    <published>2019-06-06T10:00:00.000Z</published>
    <updated>2021-08-14T12:30:42.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Swagger使用说明"><a href="#Swagger使用说明" class="headerlink" title="Swagger使用说明"></a>Swagger使用说明</h2><h3 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h3><p>Swagger是一套治理API的工具，根据OAS（Open Api Specification）这个描述API的规则，实现API盘点、测试以及归档等功能。目前在wisteria功能中，可以在嵌入很少的侵入代码的情况下实现API的盘点功能——我们可以获取到一个最新的，随时和代码保持同步的API文档。</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li><p>引入工程依赖</p><p> compile “io.springfox:springfox-swagger2:2.9.2”</p></li><li><p>添加API文档支持</p></li></ol><p>在项目中，采用开开源的springfox支持API信息的采集。 </p><p>(1)非Spring MVC项目(可以跳过该步骤)</p><p>(2)Spring MVC项目</p><p>需要在MvcConfig中增加<code>@EnableSwagger2</code>注解，同时注入Bean<code>Docket</code>即可。</p><pre><code>@Configuration@EnableSwagger2@ComponentScan(basePackages = &quot;com.xxx.frontend&quot;,    nameGenerator = FullBeanNameGenerator.class)@EnableWebMvc@EnableAspectJAutoProxy(proxyTargetClass = true)public class MvcConfig extends WebMvcConfigurerAdapter&#123;    @Bean    public Docket apiDocket() &#123;        return new Docket(DocumentationType.SWAGGER_2)                .enable(swaggerStatus)                .apiInfo(createDefaultApiInfo())                .groupName(appName + &quot;frontend&quot;)                .select()                .apis(RequestHandlerSelectors.basePackage(&quot;com.xxx&quot;))                .paths(PathSelectors.any())                .build();    &#125;    private ApiInfo createDefaultApiInfo()&#123;        return new ApiInfoBuilder()                .title(appName)                .description(appName + &quot; frontend api 文档&quot;)                .termsOfServiceUrl(&quot;http://www.xxx.cn&quot;)                .build();    &#125;&#125;</code></pre><p>(3)添加API描述</p><p>Springfox定义了一系列的注解，用于更好的描述各个API的内容，包括输入输出以及字段类型和限制等。如果不添加这些内容，API的信息也是可以获取到的，只是不是很全面而已。</p><p>描述Controller的注解：</p><p>  @Api describes the whole controller<br>  @ApiOperation is used for description on a methods level<br>  @ApiParam is used for method parameters</p><p>示例：</p><pre><code>@RestController@RequestMapping(&quot;/v2/persons/&quot;)@Api(description = &quot;Set of endpoints for Creating, Retrieving, Updating and Deleting of Persons.&quot;)public class PersonController &#123;    private PersonService personService;    @RequestMapping(method = RequestMethod.GET, path = &quot;/&#123;id&#125;&quot;, produces = &quot;application/json&quot;)    @ApiOperation(&quot;Returns a specific person by their identifier. 404 if does not exist.&quot;)    public Person getPersonById(@ApiParam(&quot;Id of the person to be obtained. Cannot be empty.&quot;)                                    @PathVariable int id) &#123;        return personService.getPersonById(id);    &#125;&#125;</code></pre><p>描述Model的注解：</p><p>示例：</p><pre><code>&#123;    @ApiModel(description = &quot;Class representing a person tracked by the application.&quot;)    public class Person &#123;    @ApiModelProperty(notes = &quot;Unique identifier of the person. No two persons can have the same id.&quot;, example = &quot;1&quot;, required = true, position = 0)    private int id;    @ApiModelProperty(notes = &quot;First name of the person.&quot;, example = &quot;John&quot;, required = true, position = 1)    private String firstName;    @ApiModelProperty(notes = &quot;Last name of the person.&quot;, example = &quot;Doe&quot;, required = true, position = 2)    private String lastName;    @ApiModelProperty(notes = &quot;Age of the person. Non-negative integer&quot;, example = &quot;42&quot;, position = 3)    private int age;    // … Constructor, getters, setters, ...&#125;</code></pre><p>支持JSR-303</p><p>  @NotNull    不为空<br>  @NotBlank   不为空 不为空字符串<br>  @Size(min = 1, max = 20)  字符串长度范围<br>  @Min(0)       最小值最大值设置<br>  @Max(100)<br>  @Pattern(regexp = “[SOME REGULAR EXPRESSION]”)   正则表达式设置  </p><p>做到上面几步就可以在api文档中看到效果了。类似如下：</p><p><img src="https://www.vojtechruzicka.com/static/57c53482f716c4648ec5d4c860c2a0e2/30398/swagger-ui.png"></p><p>或者采用不同的展示模板：</p><p><img src="https://static.oschina.net/uploads/space/2018/0716/075136_60JO_254762.png"></p><h2 id="Springfox原理"><a href="#Springfox原理" class="headerlink" title="Springfox原理"></a>Springfox原理</h2><p>Springfox生成Api文档的原理是，通过获取Spring上下文中<code>@Controller</code>以及<code>@RequestMapping</code>注解的Bean的信息，然后通过层层解析，最终按照Swagger的标准生成Api文档而得来的。</p><p>从RequestMappingHandlerMapping的一段源码上面看，就能够理解在<code>@Controller</code>和<code>@ResquestMapping</code>注解到一个Bean或其属性上之后，Spring做了什么，是如何用HandlerMapping将Http请求映射到响应的Bean的方法上的，以及是如何采用HandlerAdapter来处理Http请求的。</p><p>RequestMappingHandlerMapping中的两个关键方法：</p><pre><code>/** * &#123;@inheritDoc&#125; * Expects a handler to have a type-level @&#123;@link Controller&#125; annotation. */@Overrideprotected boolean isHandler(Class&lt;?&gt; beanType) &#123;    return (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||            AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));&#125;private RequestMappingInfo createRequestMappingInfo(AnnotatedElement element) &#123;    RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class);    RequestCondition&lt;?&gt; condition = (element instanceof Class ?            getCustomTypeCondition((Class&lt;?&gt;) element) : getCustomMethodCondition((Method) element));    return (requestMapping != null ? createRequestMappingInfo(requestMapping, condition) : null);&#125;</code></pre><p>Springfox获取Controller Bean信息的类图：</p><p><img src="/images/24.png"></p><p>参考：<br><a href="https://www.vojtechruzicka.com/documenting-spring-boot-rest-api-swagger-springfox/">https://www.vojtechruzicka.com/documenting-spring-boot-rest-api-swagger-springfox/</a></p><p><a href="https://www.v2ex.com/t/493395">https://www.v2ex.com/t/493395</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Swagger使用说明&quot;&gt;&lt;a href=&quot;#Swagger使用说明&quot; class=&quot;headerlink&quot; title=&quot;Swagger使用说明&quot;&gt;&lt;/a&gt;Swagger使用说明&lt;/h2&gt;&lt;h3 id=&quot;功能简介&quot;&gt;&lt;a href=&quot;#功能简介&quot; class=&quot;</summary>
      
    
    
    
    <category term="Swagger" scheme="http://heqiao2010.github.io/categories/Swagger/"/>
    
    
    <category term="Api管理" scheme="http://heqiao2010.github.io/tags/Api%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>记录一个MySql count细节问题</title>
    <link href="http://heqiao2010.github.io/2019/01/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AAMySql_count%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/"/>
    <id>http://heqiao2010.github.io/2019/01/01/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AAMySql_count%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/</id>
    <published>2019-01-01T10:00:00.000Z</published>
    <updated>2021-08-14T12:30:42.329Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>下面两条SQL查询结果会不一样吗？</p></blockquote><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">from</span>   (<span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> <span class="hljs-symbol">`handler_name`</span>, <span class="hljs-symbol">`retry_info`</span>, <span class="hljs-symbol">`is_disabled`</span> <span class="hljs-keyword">from</span> handler) <span class="hljs-keyword">as</span> alia;<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-symbol">`handler_name`</span>, <span class="hljs-symbol">`retry_info`</span>, <span class="hljs-symbol">`is_disabled`</span>) <span class="hljs-keyword">from</span> handler;</code></pre><h3 id="count-语法"><a href="#count-语法" class="headerlink" title="count()语法"></a>count()语法</h3><p>（1）count(*)—包括所有列，返回表中的记录数，相当于统计表的行数，在统计结果的时候，<strong>不会忽略列值为NULL的记录。</strong></p><p>（2）count(1)—忽略所有列，1表示一个固定值，也可以用count(2)、count(3)代替，在统计结果的时候，<strong>不会忽略列值为NULL的记录。</strong></p><p>（3）count(列名)—只包括列名指定列，返回指定列的记录数，在统计结果的时候，会忽略列值为NULL的记录（不包括空字符串和0），<strong>即列值为NULL的记录不统计在内。</strong></p><p>（4）count(distinct 列名)—只包括列名指定列，返回指定列的不同值的记录数，在统计结果的时候，在统计结果的时候，会忽略列值为NULL的记录（不包括空字符串和0），<strong>即列值为NULL的记录不统计在内。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于count（列名）时，为NULL时，不会统计在内，这个点，踩了个坑，这里记录一下，平时还是需要多注意下细节。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/wendychiang1991/article/details/70909958/">https://blog.csdn.net/wendychiang1991/article/details/70909958/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;下面两条SQL查询结果会不一样吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;hljs n1ql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-</summary>
      
    
    
    
    <category term="Mysql" scheme="http://heqiao2010.github.io/categories/Mysql/"/>
    
    
    <category term="MySql" scheme="http://heqiao2010.github.io/tags/MySql/"/>
    
  </entry>
  
</feed>
