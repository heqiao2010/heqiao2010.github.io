---
layout:     post
title:      "Java垃圾回收"
category:   服务端
date:       2018-06-18 18:00:00
author:     "HQ"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - Java
---

![](https://img.hacpai.com/bing/20180112.jpg?imageView2/1/w/960/h/520/interlace/1/q/100)

>在目前我参与的实际项目开发中，启动Java进程时，并没有设置额外的虚拟机参数。因为公司通过k8s集群给我们自己的业务微服务打了标签，基本上时独享整个机器的内存，所以没有增加相关的JVM参数，对这块了解也不多。在上一家公司工作的时候，测试内存溢出用的是Jprofile，运行一段时间之后，手动触发GC，看内存是否增长。

### Java虚拟机内存分区
Java虚拟机主要分为以下五个区: 

一、方法区： 

1\. 有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载 
2\. 方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。 
3\. 该区域是被线程共享的。 
4\. 方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。

二、堆 

java堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。

三、虚拟机栈: 

1\. 虚拟机栈也就是我们平常所称的栈内存,它为java方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。 
2\. 虚拟机栈是线程私有的，它的生命周期与线程相同。 
3\. 局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定 
4\.操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式 
5\.每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。

四、本地方法区 

本地方法区和虚拟机栈类似，只不过本地方法栈为Native方法（对非java语言调用的接口）服务。

五、程序计数器 

内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。

### 垃圾回收的特点
程序计数器、虚拟机栈、本地方法栈这3个区域是随线程而生而灭的，内存分配和回收都具备确定性，而Java堆和方法区则不一样，各线程共享，在运行时内存的分配与回收都是动态的，垃圾收集器所关注的是这部分内存。

### 了解垃圾回收机制的必要性
虽然垃圾回收机制已经比较成熟和稳定，但是当遇到如下情况时，就必须关注垃圾回收机制本身了。
1. 当需要排查各种内存溢出、内存泄漏问题时；
2. 当垃圾收集成为系统达到更高并发量的瓶颈时；

### 垃圾回收算法做的事情
1. 回收什么
2. 什么时候回收
3. 怎么回收

#### 1. 回收什么
1. 引用计数算法（Recference Counting）
**思路:** 给对象添加一个引用计数器，每当有一个地方引用它，计数器加1；当引用失效，计数器值减1；任何时刻计数器值为0，则认为对象是不再被使用的；
**优点:** 实现简单，判定高效，可以很好解决大部分场景的问题;
**缺点:** 1)很难解决对象之间相互循环引用的问题 2)开销较大，频繁且大量的引用变化，带来大量的额外运算;





参考1：https://blog.csdn.net/tjiyu/article/details/53982412